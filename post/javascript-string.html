<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta name="generator" content="nico 0.5.1">
    <meta name="theme" content="KISS 0.1">
    <title>Javascript String 方法效率大比拼 - 闲耘™.博客</title>
    <link rel="alternate" type="application/rss+xml" href="http://blog.hotoo.me/feed.xml" title="闲耘™.博客" />
    <link rel="stylesheet" href="../static/syntax.css" />
    <link type="text/css" rel="stylesheet" href="../static/template.css" />
  </head>
  <body>
  <div id="wrapper">
    <header class="navigation" role="navigation">
      <!--<a class="home" href="../">闲耘™.博客</a>-->
      <div style="float:right;">
        <form action="/search.html">
          <input type="text" name="q" autocomplete="off" />
          <input type="submit" value="搜索" />
        </form>
      </div>
      <nav class="menu">
        <ul>
          <li class="first"><a href="http://hotoo.me/"
            title="Home">Home</a></li>
          <li class=" actived"><a href="/"
            title="Blog">Blog</a></li>
          <li class=""><a href="http://wiki.hotoo.me/"
            title="Wiki">Wiki</a></li>
          <li class=""><a href="http://wiki.hotoo.me/Vim.html"
            title="Vim">Vim</a></li>
          <li class=""><a href="http://twitter.hotoo.me/"
            title="Twitter">Twitter</a></li>
          <li class="last"><a href="https://github.com/hotoo"
            title="Project">Project</a></li>
        </ul>
      </nav>
    </header>

<div id="container">
  <div id="content" class="document">
<div class="hentry">
  <h1 class="entry-title">Javascript String 方法效率大比拼</h1>
  <div class="entry-content"><p>最初是通过 <a href="http://blog.csdn.net/meizz">梅子</a>（<a href="http://www.meizz.com/">梅花雪</a>）
关于大型字符串拼接效率（<a href="http://blog.csdn.net/meizz/archive/2005/12/14/552260.aspx">1</a>，
<a href="http://blog.csdn.net/meizz/archive/2006/01/04/569805.aspx">2</a>）的研究得到启发，
最近又看到 never-online 的 <a href="http://www.never-online.net/blog/article.asp?id=259">从 trim 原型函数看js正则表达式的性能</a>，
里面有介绍正则表达式效率陷阱等问题，并提出解决方法。
我向来对这些鸡毛蒜皮感兴趣，也开始对大型字符串各种方法实现的效率进行比较，
并尝试提高这些方法的效率。</p>
<h2 id="大型字符串拼接">大型字符串拼接</h2><p><a href="http://blog.csdn.net/meizz/archive/2005/12/14/552260.aspx">如梅子所言</a>，
使用数组的join方法确实是最好的实现，可以根据这个思路设计StringBuilder, StringBuffer类。</p>
<h2 id="大型字符串trim">大型字符串trim</h2><p>其实never-online在他的文章里有一些说的不准确的地方，代码也不算很精炼。
既然这是鸡毛蒜皮的小事，这些零碎东西当然要斤斤计较了。
我很久以前有收集到这样一些实现，I：</p><div class="highlight"><div class="codes"><div class="code"><pre><code class="javascript">String.prototype.trim = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
<span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/(^\s+)(\s+$)/g</span>, <span class="string">''</span>);
};</code></pre></div><pre class="line"><a name="L1-1" href="#L1-1">1</a>
<a name="L1-2" href="#L1-2">2</a></pre></div></div><p>为了避免正则表达式使用括号带来的消耗，可以写成这样，II：</p><div class="highlight"><div class="codes"><div class="code"><pre><code class="javascript">String.prototype.trim = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/(?:^\s+)(?:\s+$)/g</span>, <span class="string">''</span>);
};</code></pre></div><pre class="line"><a name="L2-1" href="#L2-1">1</a>
<a name="L2-2" href="#L2-2">2</a></pre></div></div><p>另外有一套实现是这样的，III：</p><div class="highlight"><div class="codes"><div class="code"><pre><code class="javascript">String.prototype.lTrim = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s+/</span>, <span class="string">''</span>);
};
String.prototype.rTrim = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/\s+$/</span>, <span class="string">''</span>);
};
String.prototype.trim = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.lTrim().rTrim();
};</code></pre></div><pre class="line"><a name="L3-1" href="#L3-1">1</a>
<a name="L3-2" href="#L3-2">2</a>
<a name="L3-3" href="#L3-3">3</a>
<a name="L3-4" href="#L3-4">4</a>
<a name="L3-5" href="#L3-5">5</a>
<a name="L3-6" href="#L3-6">6</a>
<a name="L3-7" href="#L3-7">7</a>
<a name="L3-8" href="#L3-8">8</a></pre></div></div><p>其实调用函数也会多少有一点消耗，写成这样或许会快一点点（开个玩笑，这样写会带来
一些冗余代码，这时候就需要基于效率（时间）、代码量（空间）和可维护性方面的考量了），IV：</p><div class="highlight"><div class="codes"><div class="code"><pre><code class="javascript">String.prototype.trim = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
<span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s+/</span>, <span class="string">''</span>).replace(<span class="regexp">/\s+$/</span>, <span class="string">''</span>);
};</code></pre></div><pre class="line"><a name="L4-1" href="#L4-1">1</a>
<a name="L4-2" href="#L4-2">2</a></pre></div></div><p>后来我对正则表达式有了更多的了解，知道了贪婪与非贪婪匹配，于是自作聪明写了这一段：</p><div class="highlight"><div class="codes"><div class="code"><pre><code class="javascript">String.prototype.trim = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
<span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s*(.*?)\s*$/</span>, <span class="string">"$1"</span>); <span class="comment">// 两端空白字符贪婪匹配，中间字符非贪婪匹配。</span>
};</code></pre></div><pre class="line"><a name="L5-1" href="#L5-1">1</a>
<a name="L5-2" href="#L5-2">2</a></pre></div></div><p>我曾经为这段代码自鸣得意了好长一段时间，不过后来想到点号不包括换行符，字符串中间有换行符时，返回值就不正确了，于是不情愿的改成这样（多行模式效率也很低），V：</p><div class="highlight"><div class="codes"><div class="code"><pre><code class="javascript">String.prototype.trim = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
<span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s*((?:.\n)*?)\s*$/</span>, <span class="string">"$1"</span>);
};</code></pre></div><pre class="line"><a name="L6-1" href="#L6-1">1</a>
<a name="L6-2" href="#L6-2">2</a></pre></div></div><p>谁知，这样的代码遇到大家伙时效率会一落千丈，哎，失败。</p>
<p>原以为String.replace方法比String.substr、String.substring效率低，于是想，只使用正则表达式获得两头（或者一头）的索引位置，然后使用substring方法取出子串，VI：</p><div class="highlight"><div class="codes"><div class="code"><pre><code class="javascript">String.prototype.trim = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> l=<span class="keyword">this</span>.length;
    <span class="regexp">/^[\s]*/</span>.test(<span class="keyword">this</span>);
    <span class="comment">// /(?=[^\s])/.test(this);// -- never-online</span>
    <span class="keyword">var</span> s = RegExp.lastIndex;
    <span class="keyword">if</span>(<span class="number">1</span>==s &amp;&amp; !Char.isBlank(<span class="keyword">this</span>.charAt(<span class="number">0</span>)))s=<span class="number">0</span>;
    <span class="keyword">if</span>(s==l){<span class="keyword">return</span> <span class="string">''</span>;}
    <span class="comment">// /\s*$/.test(this);</span>
    <span class="comment">// var e=RegExp.index;</span>
    <span class="keyword">var</span> e=$lastIndexOf(<span class="function"><span class="keyword">function</span><span class="params">(c)</span>{</span><span class="keyword">return</span> !Char.isBlank(c);});
    e=-<span class="number">1</span>==e?l:e+<span class="number">1</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>.substring(s,e);
};</code></pre></div><pre class="line"><a name="L7-1" href="#L7-1">1</a>
<a name="L7-2" href="#L7-2">2</a>
<a name="L7-3" href="#L7-3">3</a>
<a name="L7-4" href="#L7-4">4</a>
<a name="L7-5" href="#L7-5">5</a>
<a name="L7-6" href="#L7-6">6</a>
<a name="L7-7" href="#L7-7">7</a>
<a name="L7-8" href="#L7-8">8</a>
<a name="L7-9" href="#L7-9">9</a>
<a name="L7-10" href="#L7-10">10</a>
<a name="L7-11" href="#L7-11">11</a>
<a name="L7-12" href="#L7-12">12</a></pre></div></div><p>而最土的方法，莫过于两头都使用循环获得索引了，VII：</p><div class="highlight"><div class="codes"><div class="code"><pre><code class="javascript">String.prototype.trim = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> f=<span class="function"><span class="keyword">function</span><span class="params">(c)</span>{</span><span class="keyword">return</span> !Char.isBlank(c);};
    <span class="keyword">var</span> l=<span class="keyword">this</span>.length, s=<span class="keyword">this</span>.$indexOf(f), e=<span class="keyword">this</span>.$lastIndexOf(f);
    <span class="keyword">if</span>(-<span class="number">1</span>==s)s=<span class="number">0</span>;
    e= -<span class="number">1</span>==e?l:e+<span class="number">1</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>.substring(s, e);
};</code></pre></div><pre class="line"><a name="L8-1" href="#L8-1">1</a>
<a name="L8-2" href="#L8-2">2</a>
<a name="L8-3" href="#L8-3">3</a>
<a name="L8-4" href="#L8-4">4</a>
<a name="L8-5" href="#L8-5">5</a>
<a name="L8-6" href="#L8-6">6</a></pre></div></div><p>代码里老是for啊for的一大串，为了节省字节，而且有可能的话，也准备再优化一下循环，
就实现了$indexOf和$lastIndexOf两个方法，可以传递一个返回boolean值的函数作为参数
（本来还想也支持正则表达式参数的，想想以前扩展indexOf和lastIndexOf方法后的效率，
就算了），这样就可以求得第一个非空白和最后一个非空白字符的位置了。</p><div class="highlight"><div class="codes"><div class="code"><pre><code class="javascript">String.prototype.$indexOf = <span class="function"><span class="keyword">function</span><span class="params">(f)</span>{</span>
    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,c,l=<span class="keyword">this</span>.length; i=<span class="number">0</span>; i--){
        c=<span class="keyword">this</span>.charAt(i);
        <span class="keyword">if</span>(f(c)){<span class="keyword">return</span> i;}
    }
    <span class="keyword">return</span> -<span class="number">1</span>;
};
String.prototype.$lastIndexOf = <span class="function"><span class="keyword">function</span><span class="params">(f)</span>{</span>
    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="keyword">this</span>.length-<span class="number">1</span>,c; i&gt;=<span class="number">0</span>; i--){
        c=<span class="keyword">this</span>.charAt(i);
        <span class="keyword">if</span>(f(c)){<span class="keyword">return</span> i;}
    }
    <span class="keyword">return</span> -<span class="number">1</span>;
};</code></pre></div><pre class="line"><a name="L9-1" href="#L9-1">1</a>
<a name="L9-2" href="#L9-2">2</a>
<a name="L9-3" href="#L9-3">3</a>
<a name="L9-4" href="#L9-4">4</a>
<a name="L9-5" href="#L9-5">5</a>
<a name="L9-6" href="#L9-6">6</a>
<a name="L9-7" href="#L9-7">7</a>
<a name="L9-8" href="#L9-8">8</a>
<a name="L9-9" href="#L9-9">9</a>
<a name="L9-10" href="#L9-10">10</a>
<a name="L9-11" href="#L9-11">11</a>
<a name="L9-12" href="#L9-12">12</a>
<a name="L9-13" href="#L9-13">13</a></pre></div></div><p>至于说要扩展到支持更长子串和起始索引，以后有需要再说了（顺便说一下，子串越长，
有优化算法可以得到更高效率）。</p>
<p>另一个辅助方法：</p><div class="highlight"><div class="codes"><div class="code"><pre><code class="javascript"><span class="keyword">var</span> Char = {
    isBlank:<span class="function"><span class="keyword">function</span><span class="params">(c)</span>{</span>
        <span class="comment">//return /\s/.test(c);</span>
        <span class="keyword">return</span> <span class="string">' '</span>==c <span class="string">'\t'</span>==c <span class="string">'\r\n'</span>==c <span class="string">'\n'</span>==c <span class="string">'\r'</span>==c;
    }
};</code></pre></div><pre class="line"><a name="L10-1" href="#L10-1">1</a>
<a name="L10-2" href="#L10-2">2</a>
<a name="L10-3" href="#L10-3">3</a>
<a name="L10-4" href="#L10-4">4</a>
<a name="L10-5" href="#L10-5">5</a></pre></div></div><p>到了永不在线(<a href="http://translate.google.com/translate_t#en%7Czh-CN%7Cnever-online">Google Translate翻译为</a>“永远在线”)的算法，VIII：</p><div class="highlight"><div class="codes"><div class="code"><pre><code class="javascript">String.prototype.trim = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> s = <span class="keyword">this</span>.replace(<span class="regexp">/^\s+/</span>, <span class="string">''</span>);
    <span class="keyword">var</span> l=s.length, e=l;
    <span class="keyword">if</span>(<span class="number">0</span>==l){<span class="keyword">return</span> <span class="string">''</span>;}
    <span class="keyword">for</span>(<span class="keyword">var</span> i=l-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--){
        <span class="keyword">if</span>(!Char.isBlank(s.charAt(i))){
            e=i+<span class="number">1</span>;
            <span class="keyword">break</span>;
        }
    }
    <span class="keyword">return</span> <span class="keyword">this</span>.substring(<span class="number">0</span>,e);
};</code></pre></div><pre class="line"><a name="L11-1" href="#L11-1">1</a>
<a name="L11-2" href="#L11-2">2</a>
<a name="L11-3" href="#L11-3">3</a>
<a name="L11-4" href="#L11-4">4</a>
<a name="L11-5" href="#L11-5">5</a>
<a name="L11-6" href="#L11-6">6</a>
<a name="L11-7" href="#L11-7">7</a>
<a name="L11-8" href="#L11-8">8</a>
<a name="L11-9" href="#L11-9">9</a>
<a name="L11-10" href="#L11-10">10</a>
<a name="L11-11" href="#L11-11">11</a></pre></div></div><p>最初这个算法让我很兴奋，直觉上，感觉这样效率肯定要高，不过事实并不是这么简单。</p>
<p>说到这些实现的效率，无法一概而论，因为不同的字符串，它们的效率比也大不同，甚至异乎寻常。</p>
<p>影响trim方法效率的，主要与字符串的总长度，前面空白字符串长度，后面空白字符串长度，
以及前中后的比例有关。详细的效率对比表有时间再上，这里只简要提一下：</p>
<p>对于较小的字符串，各种实现都有不错的表现，而对于大型字符串，则实现III,
IV表现较为稳定，甚至可以处理超大型字符串（修正：之前有误写成I，II两个较为稳定）。</p>
<h2 id="大型字符串字节长度">大型字符串字节长度</h2><p>即双字节长度为2。注意：这个提法其实也不正确，Javascript是使用Unicode字符集的，
所有的字符都（有可能）是双字节字符。将汉字等转换为双字节长度主要是为了某些应用。
最土的方法还是循环遍历所有字符，I：</p><div class="highlight"><div class="codes"><div class="code"><pre><code class="javascript">String.prototype.bytes = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> l=<span class="keyword">this</span>.length, r=l, n=<span class="number">0xff</span>;
    <span class="keyword">for</span>(<span class="keyword">var</span> i=l; i&gt;=<span class="number">0</span>; i--){
        <span class="keyword">if</span>(<span class="keyword">this</span>.charCodeAt(i)&gt;n){
            r++;
        }
    }
    <span class="keyword">return</span> r;
};</code></pre></div><pre class="line"><a name="L12-1" href="#L12-1">1</a>
<a name="L12-2" href="#L12-2">2</a>
<a name="L12-3" href="#L12-3">3</a>
<a name="L12-4" href="#L12-4">4</a>
<a name="L12-5" href="#L12-5">5</a>
<a name="L12-6" href="#L12-6">6</a>
<a name="L12-7" href="#L12-7">7</a>
<a name="L12-8" href="#L12-8">8</a></pre></div></div><p>这里判断字符是否双字节有很多方法，效率较高的之间相差（大概）不大。</p>
<p>另一种实现则看起来很轻灵，寥寥几行，II：</p><div class="highlight"><div class="codes"><div class="code"><pre><code class="javascript">String.prototype.bytes = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
<span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/[^\x00-\xff]/g</span>,<span class="string">"xx"</span>).length;
};</code></pre></div><pre class="line"><a name="L13-1" href="#L13-1">1</a>
<a name="L13-2" href="#L13-2">2</a></pre></div></div><p>多动脑子，则想法愈多（也常把简单的事情复杂化），我想如果可以快速取得表达式
(双字节/单字节)匹配次数，两值相加应该比较高效，III：</p><div class="highlight"><div class="codes"><div class="code"><pre><code class="javascript">String.prototype.bytes = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.length+<span class="keyword">this</span>.replace(<span class="regexp">/[\x00-\xff]/g</span>,<span class="string">""</span>).length;
};</code></pre></div><pre class="line"><a name="L14-1" href="#L14-1">1</a>
<a name="L14-2" href="#L14-2">2</a></pre></div></div><p>IV：</p><div class="highlight"><div class="codes"><div class="code"><pre><code class="javascript">String.prototype.bytes = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.length+(<span class="keyword">this</span>.match(<span class="regexp">/[^\x00-\xff]/g</span>)<span class="string">""</span>).length;
};</code></pre></div><pre class="line"><a name="L15-1" href="#L15-1">1</a>
<a name="L15-2" href="#L15-2">2</a></pre></div></div><p>另外看到梅花雪用数组能提供字符串拼接速度，也想：把字符串split为数组，
不想对大型字符串而言，这split一步就慢得不行。</p>
<p>bytes方法的效率：使用Javascript脚本循环大型字符串（I），确实远不如内置的
replace方法（II）快，而使用正则表达式match方法（IV）又比replace方法（III）稍快，
排名第二。</p>
<h2 id="总结：">总结：</h2><ul>
<li>replace方法因匹配而被替换的子串愈长，效率愈低。</li>
<li>根据目标字符串，选择合适的实现。</li>
</ul>
</div>

  <footer class="entry-meta post clearfix">
    <span class="tags"><a href="/tag">Tags</a>:
 
      <a href="/tag/#JavaScript">JavaScript</a>
      
 , 
      <a href="/tag/#性能">性能</a>
      
 , 
      <a href="/tag/#算法">算法</a>
      
    </span>

    <time datetime="2008-12-29T00:00:00.000Z">
      <a href="/2008">2008年</a>12月29日
    </time>
  </footer>
    <section>
      <div id="disqus_thread"></div>
      <noscript>
        要查看或参与评论，请启用 JavaScript 支持。<br />
        Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=hotoo">comments powered by Disqus.</a>
      </noscript>
    </section>
  <script type="text/javascript">
    
    var disqus_identifier = "javascript-string";
    
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'http://hotoo.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  </script>
</div>
</div>

    <!-- Vimlike status bar -->
    <div id="status-bar">
        <span id="count"></span>
    </div>
</div>
<div id="helper-box"></div>
<div id="helper" tabindex="1">
    <table>
    <thead>
        <tr>
            <th colspan="2">Help</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th width="120">[count]gg</th>
            <td>跳转到第 [count] 行，默认第 1 行。</td>
        </tr>
        <tr>
            <th>[count]G</th>
            <td>跳转到第 [count] 行，默认最后一行。</td>
        </tr>
        <tr>
            <th>[count]j</th>
            <td>向下跳转 [count] 行，默认跳转一行。</td>
        </tr>
        <tr>
            <th>[count]k</th>
            <td>向上跳转 [count] 行，默认跳转一行。</td>
        </tr>
        <tr>
            <th>/</th>
            <td>开始搜索。按 &lt;Esc&gt; 退出。</td>
        </tr>
        <tr>
            <th>gh</th>
            <td>跳转到首页。</td>
        </tr>
        <tr>
            <th>gb</th>
            <td>跳转到博客首页。</td>
        </tr>
        <tr>
            <th>gw</th>
            <td>跳转到 Wiki 首页。</td>
        </tr>
        <tr>
            <th>gt</th>
            <td>跳转到我的 Twitter Profile 页。</td>
        </tr>
        <tr>
            <th>gp</th>
            <td>跳转到我的 Github Profile 页。</td>
        </tr>
        <tr>
            <th>?</th>
            <td>打开帮助。按 &lt;Esc&gt; 退出。</td>
        </tr>
    </tbody>
    </table>
</div>

<script type="text/javascript" src="/static/js/Vimlike.js"></script>
<footer>
  <p><a rel="license" href="http://creativecommons.org/licenses/by/2.5/"><img
    alt="Creative Commons License" style="border-width: 0pt;"
    src="http://i.creativecommons.org/l/by/2.5/88x31.png" align="right"/></a>
  This work is licensed under a
  <a rel="license" href="http://creativecommons.org/licenses/by/2.5/">Creative
    Commons Attribution 2.5 Generic License</a>.<br/>
  Copyleft &copy; 2005-2013, Power by
  <a href="http://lab.lepture.com/nico/">nico@0.5.1</a>, Theme by 闲耘™(@hotoo).
  </p>
</footer>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-2048484-1', 'auto');
  ga('send', 'pageview');

</script>

  </body>
</html>