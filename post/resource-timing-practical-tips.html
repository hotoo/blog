<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta name="generator" content="nico 0.5.2">
    <meta name="theme" content="KISS 0.1">
    <title>译：Resource Timing (资源计时) 使用技巧 - 闲耘™.博客</title>
    <link rel="alternate" type="application/rss+xml" href="https://hotoo.github.io/blog//feed.xml" title="闲耘™.博客" />
    <link rel="stylesheet" href="../static/syntax.css" />
    <link type="text/css" rel="stylesheet" href="../static/template.css" />
  </head>
  <body>
  <div id="wrapper">
    <header class="navigation" role="navigation">
      <!--<a class="home" href="../">闲耘™.博客</a>-->
      <div style="float:right;">
        <form action="/blog/search.html">
          <input type="text" name="q" autocomplete="off" />
          <input type="submit" value="搜索" />
        </form>
      </div>
      <nav class="menu">
        <ul>
          <li class="first"><a href="https://hotoo.github.io/"
            title="Home">Home</a></li>
          <li class=" actived"><a href="/blog/"
            title="Blog">Blog</a></li>
          <li class=""><a href="https://hotoo.github.io/wiki/"
            title="Wiki">Wiki</a></li>
          <li class=""><a href="https://hotoo.github.io/wiki/Vim.html"
            title="Vim">Vim</a></li>
          <li class=""><a href="https://hotoo.github.io/twitter/"
            title="Twitter">Twitter</a></li>
          <li class="last"><a href="https://github.com/hotoo"
            title="Project">Project</a></li>
        </ul>
      </nav>
    </header>

<div id="container">
  <div id="content" class="document">
<div class="hentry">
  <h1 class="entry-title">译：Resource Timing (资源计时) 使用技巧</h1>
  <div class="entry-content"><p><a href="http://www.w3.org/2010/webperf/">W3C Web 性能工作组</a> 在 2012 年给我们带来了
<a href="http://www.w3.org/TR/navigation-timing/">Navigation Timing</a>，这个 API 现在
基本上在主流浏览器上都可用。Navigation Timing 定义了一套用于测量主页面性能的
JavaScript API。例如：</p><div class="highlight"><div class="codes"><div class="code"><pre><code class="javascript"><span class="hljs-comment">// Navigation Timing</span>
<span class="hljs-keyword">var</span> t = performance.timing,
    pageloadtime = t.loadEventStart - t.navigationStart,
    dns = t.domainLookupEnd - t.domainLookupStart,
    tcp = t.connectEnd - t.connectStart,
    ttfb = t.responseStart - t.navigationStart;</code></pre></div><pre class="line"><a name="L1-1" href="#L1-1">1</a>
<a name="L1-2" href="#L1-2">2</a>
<a name="L1-3" href="#L1-3">3</a>
<a name="L1-4" href="#L1-4">4</a>
<a name="L1-5" href="#L1-5">5</a>
<a name="L1-6" href="#L1-6">6</a></pre></div></div><a name="more"></a>

<p>能够度量主页面的时间消耗真是太棒了，但是要诊断现实当中的性能问题，往往需要深入
到各个资源当中。所以我们拥有了更进一步的 Resource Timing （资源计时）规范，
这个 JavaScript API 提供类似 Navigation Timing 的功能，但是能精确到每一个资源的
耗时。举个例子：</p><div class="highlight"><div class="codes"><div class="code"><pre><code class="javascript"><span class="hljs-comment">// Resource Timing</span>
<span class="hljs-keyword">var</span> r0 = performance.getEntriesByType(<span class="hljs-string">"resource"</span>)[<span class="hljs-number">0</span>],
    loadtime = r0.duration,
    dns = r0.domainLookupEnd - r0.domainLookupStart,
    tcp = r0.connectEnd - r0.connectStart,
    ttfb = r0.responseStart - r0.startTime;</code></pre></div><pre class="line"><a name="L2-1" href="#L2-1">1</a>
<a name="L2-2" href="#L2-2">2</a>
<a name="L2-3" href="#L2-3">3</a>
<a name="L2-4" href="#L2-4">4</a>
<a name="L2-5" href="#L2-5">5</a>
<a name="L2-6" href="#L2-6">6</a></pre></div></div><p>到目前为止，Chrome, Chrome for Android, Opera, IE10 和 IE11
浏览器都支持 Resource Timing，这也许超过了你的网站 50% 的流量。
这应该可以提供足够的数据，来揭示这些资源缓慢的原因。</p>
<p>使用 Resource Timing 看似很简单，但是当我在写第一个用于生产环境的 Resource Timing 代码
时，遇到了许多问题。这里我想分享一些现实当中记录 Resource Timing 指标的实用技巧。</p>
<h2 id="1-使用-getentriesbytype-quot-resource-quot-而不是-getentries">1. 使用 <code>getEntriesByType(&quot;resource&quot;)</code> 而不是 <code>getEntries()</code></h2><p>在使用 Resource Timing 来获取当前页面的资源集合的资源耗时性能对象时，许多 Resource
Timing 示例都是使用 <code>performance.getEntries()</code>，这意味着唯一的 resource timing 对象
由该调用进行返回。但是 <code>getEntries()</code> 会一并返回潜在的 <a href="http://www.w3.org/wiki/Web_Performance/EntryType">4 种类型的 timing 对象</a>：
<code>resource</code>（资源），<code>navigation</code> （导航）, <code>mark</code> （标记）, 和 <code>measure</code> （测量）。</p>
<p>这并没有造成多大问题，因为目前 <code>resource</code> 是大多数网页的唯一类型。
<code>navigation</code> 类型是 <a href="http://www.w3.org/TR/navigation-timing-2/">Navigation Timing 2</a> 的一部分，据我所知目前没有被任何浏览器所实现。
<code>mark</code> 和 <code>measure</code> 类型是从 <a href="http://www.w3.org/TR/user-timing/">User Timing</a> 规范衍生出来的，在部分浏览器中可用，
但是还没有被广泛使用。</p>
<p>也就是说，<code>getEntriesByType(&quot;resource&quot;)</code> 以及 <code>getEntries()</code> 在今天可能返回相同
的结果，但是可能 <code>getEntries()</code> 将很快返回多种性能对象的混合集合，所以最好是
使用 <code>performance.getEntriesByType(&quot;resource&quot;)</code>，你可以明确的只获取 resource
timing 对象。（感谢 <a href="http://calendar.perfplanet.com/2012/an-introduction-to-the-resource-timing-api/">Andy Davies</a> 给我解释这一点）</p>
<h2 id="2-使用-navigation-timing-测量主页面的请求。">2. 使用 Navigation Timing 测量主页面的请求。</h2><p>当通过典型的请求获取一个网页的主 HTML 文档，但是这个资源并不能通过
<code>performance.getEntriesByType(&quot;resource&quot;)</code> 得到返回，要得到这个主页面 HTML 文档
的 timing 信息，需要使用 Navigation Timing 对象（<code>performance.timing</code>）。</p>
<p>虽然不太可能，当页面上没有其他资源时，这可能会导致错误发生。
例如，刚才 Resource Timing 示例使用如下代码：</p><div class="highlight"><div class="codes"><div class="code"><pre><code class="javascript">performance.getEntriesByType(<span class="hljs-string">"resource"</span>)[<span class="hljs-number">0</span>]</code></pre></div><pre class="line"><a name="L3-1" href="#L3-1">1</a></pre></div></div><p>如果一个页面唯一的资源就是主页面的 HTML 文档，然后 <code>getEntriesByType(&quot;resource&quot;)</code>
返回一个空数组，这时候应用 <code>element[0]</code> 会引起 JavaScript 异常。如果你找不到
没有引用子资源的页面，你可以试试 <a href="http://fast.stevesouders.com/">http://fast.stevesouders.com/</a></p>
<h2 id="3-小心-secureconnectionstart-的问题。">3. 小心 <code>secureConnectionStart</code> 的问题。</h2><p><a href="http://www.w3.org/TR/resource-timing/#dom-performanceresourcetiming-secureconnectionstart"><code>secureConnectionStart</code></a>
属性我们衡量 SSL 协商需要多长时间。这非常重要，我经常
看到 500 毫秒以上的 SSL 协商时间，甚至更多。<code>secureConnectionStart</code> 有 3 种
可能的值：</p>
<ul>
<li>如果该属性不可用，则必须设置为 <code>undefined</code>。</li>
<li>如果不使用 HTTPS 的，则必须设置为 0.</li>
<li>如果该属性可用，并且使用了 HTTPS，则必须设置为一个时间戳。</li>
</ul>
<p>关于 <code>secureConnectionStart</code>，有三件事情需要了解下：</p>
<p>首先，在 Internet Explorer 中，<code>secureConnectionStart</code> 的值总是 <code>undefined</code>，
因为它是不可用的（该值被埋在 <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa383630(v=vs.85\">WinINet</a>.aspx) 之下）。</p>
<p>其次，在 Chrome 中有个 BUG 会导致 <code>secureConnectionStart</code> 被错误的设置为 0 的问题。
如果获取一个资源时使用预先存在的 HTTPS 连接，则 <code>secureConnectionStart</code> 将被设置
为 0，而实际上它应该是一个时间戳。（详情请参考 <a href="https://code.google.com/p/chromium/issues/detail?id=404501">bug 404501</a> ）
为了避免这个问题，测量 SSL 协商时间时，一定要检查 <code>secureConnectionStart</code> 既不是
<code>undefined</code> 也不是 <code>0</code>：</p><div class="highlight"><div class="codes"><div class="code"><pre><code class="javascript"><span class="hljs-keyword">var</span> r0 = performance.getEntriesByType(<span class="hljs-string">"resource"</span>)[<span class="hljs-number">0</span>];
<span class="hljs-keyword">if</span> ( r0.secureConnectionStart ) {
    <span class="hljs-keyword">var</span> ssl = r0.connectEnd - r0.secureConnectionStart;
}</code></pre></div><pre class="line"><a name="L4-1" href="#L4-1">1</a>
<a name="L4-2" href="#L4-2">2</a>
<a name="L4-3" href="#L4-3">3</a>
<a name="L4-4" href="#L4-4">4</a></pre></div></div><p>第三，规范中关于 <a href="http://www.w3.org/TR/resource-timing/#dom-performanceresourcetiming-secureconnectionstart">这一行</a>
有一些误导：“...如果当前页面的协议是 HTTPS，这个属性必须立即返回用户代理(user agent)开始握手过程的时间...”
（我的重点）。有可能当前页面是 HTTP，但仍然包含我们需要测量 SSL 协商时间的 HTTPS 资源。
规范应该改为：“...如果资源的协议是 HTTPS 协议，该属性必须立即返回用户代理开始握手过程的时间...”。
幸运的是，浏览器是使用纠正后的行为，而已就是说， <code>secureConnectionStart</code> 可用于
HTTP 页面中的 HTTPS 资源。</p>
<h2 id="4-给跨域资源添加-timing-allow-origin-http-响应头">4. 给跨域资源添加 <code>Timing-Allow-Origin</code> HTTP 响应头</h2><p>出于隐私保护的原因，在获得资源的 Resource Timing 详情时有<a href="http://www.w3.org/TR/resource-timing/#cross-origin-resources">跨域限制</a>。
默认情况下，与主页面不同域的资源，下列属性被设置为 0：</p>
<ul>
<li>redirectStart</li>
<li>redirectEnd</li>
<li>domainLookupStart</li>
<li>domainLookupEnd</li>
<li>connectStart</li>
<li>connectEnd</li>
<li>secureConnectionStart</li>
<li>requestStart</li>
<li>responseStart</li>
</ul>
<p>在某些情况下，仍然希望测量跨域资源的性能，例如，当网站使用不用域名的 CDN（例如
&quot;youtube.com&quot; 使用 &quot;s.ytimg.com&quot;），以及某些第三方资源（例如 &quot;ajax.googleapis.com&quot;）。
如果资源返回 <a href="http://www.w3.org/TR/resource-timing/#timing-allow-origin">Timing-Allow-Origin</a>
响应头，跨域资源的 timing 详情将被授权访问。这个头信息指定了被允许访问 timing
详情的（主页面）来源列表，多数情况下，会使用通配符(<code>*</code>) 允许所有来源访问。
举个例子，<a href="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js">http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js</a> 返回
的 Timing-Allow-Origin 响应头信息是：</p><div class="highlight"><div class="codes"><div class="code"><pre>Timing-Allow-Origin: *</pre></div><pre class="line"><a name="L5-1" href="#L5-1">1</a></pre></div></div><p>当第三方添加这个响应头信息时，真是太棒了。它允许站长来统计在他们网页上使用的
第三方资源的性能。感谢 <a href="http://googledevelopers.blogspot.com/2013/12/measuring-network-performance-with.html">Ilya Grigorik</a>
报告了一些添加了这个响应头的第三方资讯，下面是一些指定了 <code>Timing-Allow-Origin: *</code>
的资源例子：</p>
<ul>
<li>Google Hosted Libraries: <a href="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js">http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js</a></li>
<li>Google+ widgets: <a href="https://apis.google.com/js/plusone.js">https://apis.google.com/js/plusone.js</a></li>
<li>Google Fonts:  <a href="http://fonts.gstatic.com/s/opensans/v9/DXI[snip...]N3Vs.woff2">http://fonts.gstatic.com/s/opensans/v9/DXI[snip...]N3Vs.woff2</a></li>
<li>Facebook widgets: <a href="http://connect.facebook.net/en_US/all.js">http://connect.facebook.net/en_US/all.js</a></li>
<li>Disqus widgets: <a href="http://go.disqus.com/embed.js">http://go.disqus.com/embed.js</a></li>
</ul>
<p>当需要访问有限制的 timing 属性时，决定统计 Resource Timing 是非常重要的。
可以通过检测（上面列出的，secureConnectionStart 除外）限制性属性是否为 0 的方式
来避免限制性问题，我总是使用 <code>requestStart</code>。下面是用于在计算详细的性能指标之前，
检测和计算限制性属性是否可用的代码片段：</p><div class="highlight"><div class="codes"><div class="code"><pre><code class="javascript"><span class="hljs-comment">// Resource Timing</span>
<span class="hljs-keyword">var</span> r0 = performance.getEntriesByType(<span class="hljs-string">"resource"</span>)[<span class="hljs-number">0</span>],
    loadtime = r0.duration;
<span class="hljs-keyword">if</span> ( r0.requestStart ) {
    <span class="hljs-keyword">var</span> dns = r0.domainLookupEnd - r0.domainLookupStart,
        tcp = r0.connectEnd - r0.connectStart,
        ttfb = r0.responseStart - r0.startTime;
}
<span class="hljs-keyword">if</span> ( r0.secureConnectionStart ) {
    <span class="hljs-keyword">var</span> ssl = r0.connectEnd - r0.secureConnectionStart;
}</code></pre></div><pre class="line"><a name="L6-1" href="#L6-1">1</a>
<a name="L6-2" href="#L6-2">2</a>
<a name="L6-3" href="#L6-3">3</a>
<a name="L6-4" href="#L6-4">4</a>
<a name="L6-5" href="#L6-5">5</a>
<a name="L6-6" href="#L6-6">6</a>
<a name="L6-7" href="#L6-7">7</a>
<a name="L6-8" href="#L6-8">8</a>
<a name="L6-9" href="#L6-9">9</a>
<a name="L6-10" href="#L6-10">10</a>
<a name="L6-11" href="#L6-11">11</a></pre></div></div><p>做这些检测是非常重要的，否则，当访问这些受限属性时，你不会得到任何异常，除了
这些虚假的数据。当属性受限访问时，它们的值被设置为 0，例如 <code>domainLookupEnd - domainLookupStart</code>
翻译成 <code>0 - 0</code>，它返回一个似是而非的结果 <code>0</code>，而这可能并不是真实 DNS 查询时间。
这将导致过多的指标为 <code>0</code> 而让你过于乐观。</p>
<h2 id="5-理解-0-意味着什么。">5. 理解 0 意味着什么。</h2><p>在第 4 节当中提到，一些因为跨域导致的受限访问的 Resource Timing 属性会被设置为
0。再强调一次，在访问属性详情之前，要检查属性状态是非常重要的。
但是即使受限属性都是可访问的，度量计算的返回结果也有可能是 0，所以理解这意味着
什么非常重要。</p>
<p>例如，（假设没有访问限制）<code>domainLookupStart</code> 和 <code>domainLookupEnd</code> 的值是两个
时间戳，这两个值之差是该资源在 DNS 解析上耗时。通常情况下，一个页面中指定的域名
只有一个非 0 的 DNS 解析耗时，因为浏览器会缓存 DNS 解析，所有后续的请求都使用
这个缓存的 DNS 解析。而且由于跨页面的 DNS 解析缓存，一个页面所有的 DNS 解析
计算结果可能都是 0。关键点：DNS 解析耗时为 0 意味着资源是从缓存中读取的。</p>
<p>同样，对于指定的主机名，如果重复利用已存在的 TCP 连接，那么建立 TCP 连接（<code>connectEnd - connectStart</code>）
的耗时也会是 0。每个主机有大约 6 个独立的 TCP 连接，这表明应该有 6 个非 0 的
TCP 连接测量值，但是这个主机后续的请求将使用已存在的 TCP 连接，并且他们的
TCP 连接耗时为 0。关键点：TCP 连接耗时为 0 意味着重复使用了已存在的 TCP 连接。</p>
<p>这同样适用于计算 SSL 协商（<code>connectEnd - secureConnectionStart</code>）。这个可能
有 6 个以上的资源，但是同一主机名的所有的后续请求可能都使用同一个已存在的 HTTPS
连接，以至于它的 SSL 协商时间为 0。</p>
<p>最后，如果属性持续的为 0，这可能意味资源是从缓存中读取的。</p>
<h2 id="6-确定-304-是否被测量。">6. 确定 304 是否被测量。</h2><p>这是另一个 Chrome 稳定版（版本号 36）的 BUG，这个 BUG 在 37 版时被修复。
这个问题已经被修复了，但是由于大多数用户还是使用 Chrome 稳定版，你当前的性能
指标可能跟实际上的并不相同。这个 BUG 是：一个拥有 Timing-Allow-Origin 的跨域
页面，200 响应状态并不会考虑 304 响应状态，因此，304 响应下所有的受限属性都
将显示为 0，例如 <a href="http://stevesouders.com/tests/tao.php">这个测试页面</a>。</p>
<p>这是不应该发生的，因为从 200 响应的缓存中读取的 Timing-Allow-Origin 头信息
应该应用到 304 响应中。在 Internet Explorer 浏览器中就是这样。（可以在 IE 10
或者 11 中尝试 <a href="http://stevesouders.com/tests/tao.php">这个页面</a> 来确认。）
（感谢 <a href="https://twitter.com/ericlaw">Eric Lawrence</a> 指出这一点。）</p>
<p>这会影响你的 Chrome Resource Timing 结果如下：</p>
<ul>
<li>如果（如第 4 节所述）使用检查 0 值的方式来判断受限字段，则会跳过测量 304 响应，
也就是说值测量了 200 状态响应，但是由于 200 状态响应比 304 要慢，所以 Resource
Timing 测量总量会比实际的要大。</li>
<li>反之如果不检查受限字段为 0 的情况，会得到许多的 0 值记录，
这实际上又比 304 响应要快，这样 Resource Timing 统计结果又会过于乐观。</li>
</ul>
<p>没有简单的方式来避免这些偏见，但是好消息是这个 BUG 被修复了。另外还可以尝试做的
事情是，304 响应头中发送 Timing-Allow-Origin 头，不幸的是，流行的 Apache Web
服务器不支持在 304 响应头中发送这个头信息（查看 <a href="https://issues.apache.org/bugzilla/show_bug.cgi?id=51223">BUG 51223</a>）。
缺乏进一步证件证明第 4 节提到那些第三方资源的 304 响应头中的 Timing-Allow-Origin
可以被找到。如前所述，这些第三方资源在 200 响应头中返回 Timing-Allow-Origin 头，
但是 304 响应头中不返回 Timing-Allow-Origin 头，这真是太好了。
到 Chrome 37 成为稳定版之前，因为缺少了受限属性的细节，Resource Timing 测量结果
可能偏高或偏低。幸运的是，时间会改变一切。</p>
<h2 id="7-看看-boomerang（回旋镖）">7. 看看 Boomerang（回旋镖）.</h2><p>如果你准备写自己 Resource Timing 代码，建议你最好看看 <a href="http://www.lognormal.com/boomerang/doc/api/restiming.html">Resource Timing 插件 Boomerang</a>。
（代码在 <a href="https://github.com/lognormal/boomerang/blob/master/plugins/restiming.js">GitHub</a> 上。）
Boomerang 是 Philip Tellis 维护的一个非常流行的开源 RUM 包。他起初在 Yahoo 工作
的时候就开源了 Boomerang，而现在作为在 SOASTA 工作的商业版的一部分（mPulse），
他仍然在持续的提供维护和增强。t它的代码很清晰、简洁和健壮，并解决了上面提到的许多问题。</p>
<p>总之，Navigation Timing 和 Resource Timing 都是非常优秀的新规范，为站长了解他们
的页面性能提供了很好的支持。Resource Timing 是这两个规范中更新的一个规范，因此
还是会有一些问题待解决。这些小提示将帮助你充分的利用 Resource Timing 指标。
我建议你现在就开始监控这些指标，以理解你的网站性能，为了最关心这个问题的真实用户。</p>
<blockquote>
<p>更新：有一些第三方资源提供了 Timing-Allow-Origin 响应头，以允许站长测量这些
第三方资源的性能：</p>
<ul>
<li>Boomerang: <a href="http://c.go-mpulse.net/boomerang/CEN[snip...]YQE">http://c.go-mpulse.net/boomerang/CEN[snip...]YQE</a></li>
<li>Typekit: <a href="https://use.typekit.net/previewkits/pk-v1.js">https://use.typekit.net/previewkits/pk-v1.js</a></li>
</ul>
</blockquote>
<p/>

<blockquote>
<p>更新：<code>getEntriesByType(&quot;resource&quot;)</code> 和 <code>getEntries()</code> 不包含 iframe 页面的性能，
如果 iframe 是同源的，可以在父页面通过 <code>contentWindow.performance</code> 对象访问
这些指标。</p>
</blockquote>
<h2 id="译者补充">译者补充</h2><ul>
<li><a href="http://www.stevesouders.com/blog/2014/08/21/resource-timing-practical-tips/">Resource Timing practical tips</a> - 原文出处。</li>
</ul>
</div>

  <footer class="entry-meta post clearfix">
    <span class="tags"><a href="../tag">Tags</a>:
 
      <a href="/tag/#HTML5">HTML5</a>
      
 , 
      <a href="/tag/#翻译">翻译</a>
      
    </span>

    <time datetime="2014-12-30T00:00:00.000Z">
      <a href="../2014">2014年</a>12月30日
    </time>
  </footer>
    <section>
      <div id="disqus_thread"></div>
      <noscript>
        要查看或参与评论，请启用 JavaScript 支持。<br />
        Please enable JavaScript to view the <a href="https://github.com/hotoo/blog/issues">comments powered by Gitment.</a>
      </noscript>
    </section>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script type="text/javascript">
    
    var disqus_identifier = "resource-timing-practical-tips";
    

    var gitment = new Gitment({
      id: disqus_identifier, // 可选。默认为 location.href
      owner: 'hotoo',
      repo: 'blog',
      oauth: {
        client_id: '2ac185fc670562ffa0aa',
        client_secret: '248f4f2d70ed28b1e3e70113db27d46067a981a8',
      },
    })
    gitment.render('disqus_thread');

    // var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    // dsq.src = 'http://hotoo.disqus.com/embed.js';
    // (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  </script>
</div>
</div>

    <!-- Vimlike status bar -->
    <div id="status-bar">
        <span id="count"></span>
    </div>
</div>
<div id="helper-box"></div>
<div id="helper" tabindex="1">
    <table>
    <thead>
        <tr>
            <th colspan="2">Help</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th width="120">[count]gg</th>
            <td>跳转到第 [count] 行，默认第 1 行。</td>
        </tr>
        <tr>
            <th>[count]G</th>
            <td>跳转到第 [count] 行，默认最后一行。</td>
        </tr>
        <tr>
            <th>[count]j</th>
            <td>向下跳转 [count] 行，默认跳转一行。</td>
        </tr>
        <tr>
            <th>[count]k</th>
            <td>向上跳转 [count] 行，默认跳转一行。</td>
        </tr>
        <tr>
            <th>/</th>
            <td>开始搜索。按 &lt;Esc&gt; 退出。</td>
        </tr>
        <tr>
            <th>gh</th>
            <td>跳转到首页。</td>
        </tr>
        <tr>
            <th>gb</th>
            <td>跳转到博客首页。</td>
        </tr>
        <tr>
            <th>gw</th>
            <td>跳转到 Wiki 首页。</td>
        </tr>
        <tr>
            <th>gt</th>
            <td>跳转到我的 Twitter Profile 页。</td>
        </tr>
        <tr>
            <th>gp</th>
            <td>跳转到我的 Github Profile 页。</td>
        </tr>
        <tr>
            <th>?</th>
            <td>打开帮助。按 &lt;Esc&gt; 退出。</td>
        </tr>
    </tbody>
    </table>
</div>

<script type="text/javascript" src="/blog/static/js/Vimlike.js"></script>
<footer>
  <p><a rel="license" href="http://creativecommons.org/licenses/by/2.5/"><img
    alt="Creative Commons License" style="border-width: 0pt;"
    src="http://i.creativecommons.org/l/by/2.5/88x31.png" align="right"/></a>
  This work is licensed under a
  <a rel="license" href="http://creativecommons.org/licenses/by/2.5/">Creative
    Commons Attribution 2.5 Generic License</a>.<br/>
  Copyleft &copy; 2005-2017, Power by
  <a href="http://lab.lepture.com/nico/">nico@0.5.2</a>, Theme by 闲耘™(@hotoo).
  </p>
</footer>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-2048484-1', 'auto');
  ga('send', 'pageview');

</script>

  </body>
</html>