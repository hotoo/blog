<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>闲耘™.博客</title>
    <link href="http://blog.hotoo.me/feed.xml" rel="self" />
    <link href="http://blog.hotoo.me/feed.xml" />
    <id>http://blog.hotoo.me/feed.xml</id>
    <entry>
        <title type="html"><![CDATA[Git 提效篇]]></title>
        <link href="http://blog.hotoo.me/post/git-branch"/>
        <published>2017-05-21T00:00:00.000Z</published>
        <updated>2017-05-21T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/git-branch</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <h2 id="分支备注">分支备注</h2><p>集团的流程工具会生成一团奇形怪状的分支名称，要记忆这些分支名是一项难题，默认的 <code>git branch</code> 列出的本地分支都是几乎无法识别的乱码，如果快速标识并识别出这些分支呢？</p>
<h3 id="备注分支">备注分支</h3><div class="highlight"><pre><code class="bash">$ git config branch.ANT01942367_20170510_wealthbffweb.description <span class="hljs-string">"小聚宝 2.1"</span>
$ git branch
  ANT01730954_20170224_wealthbffweb
  ANT01785082_20170316_wealthbffweb
  ANT01824187_20170329_wealthbffweb
* ANT01942367_20170510_wealthbffweb
$ git config branch.ANT01942367_20170510_wealthbffweb.description
小聚宝 2.1</code></pre></div><p>还可以使用 <code>git branch --edit-description</code> 命令编辑复杂的备注信息。</p>
<h3 id="显示备注">显示备注</h3><p>默认 <code>git branch</code> 列出的本地分支不会附带备注信息，git 内置的 <code>git config branch.{branch_name}.description</code> 可以显示单个分支的备注。</p>
<p>以下方法可以一次性列出所有分支，并附上各个分支对应的备注信息。</p>
<div class="highlight"><pre><code class="bash">$ npm install git-br -g
$ git config --global alias.br !git-br
$ git br
  ANT01730954_20170224_wealthbffweb 资产质押 250
  ANT01785082_20170316_wealthbffweb 小聚宝 2.0
  ANT01824187_20170329_wealthbffweb 中间页
* ANT01942367_20170510_wealthbffweb 小聚宝 2.1</code></pre></div><h2 id="分支别名">分支别名</h2><p>上面的方法备注了一团乱码的分支名，但真正要切换到这种分支时，仍然需要 <code>git br</code> 列出所有分支，并从中找出目标分支，复制，<code>git co &lt;C-v&gt;</code>，有没有更便捷的方法呢，答案是肯定的。</p>
<h3 id="git-symbolic-ref">git symbolic-ref</h3><p>Git 内置了强大的 symbolic-ref 方法，可以给分支增加引用（别名）：</p>
<div class="highlight"><pre><code class="bash">$ git symbolic-ref refs/heads/{<span class="hljs-built_in">alias</span>Name} refs/heads/{未知分支}
$ git co {<span class="hljs-built_in">alias</span>Name}
Switched to branch <span class="hljs-string">'{aliasName}'</span>
; 这时候会切换到 {未知分支}</code></pre></div><h2 id="参考">参考</h2><ul>
<li><a href="https://github.com/bahmutov/git-branches">https://github.com/bahmutov/git-branches</a></li>
<li><a href="https://gist.github.com/mauricerkelly/0b12b20a870d1e38081e">https://gist.github.com/mauricerkelly/0b12b20a870d1e38081e</a></li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[HTML Tabs 最佳实践]]></title>
        <link href="http://blog.hotoo.me/post/html-tabs"/>
        <published>2017-03-21T00:00:00.000Z</published>
        <updated>2017-03-21T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/html-tabs</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p>Tabs 面板的显示和隐藏一般以 display 来控制显示和隐藏，但是如果默认未显示的 Tabs 面板中渲染需要知道面板宽高的组件
（如 Canvas，某些轮播组件等）时，就会因为面板在 display:none 的状态下无法拿到宽高导致渲染组件异常。</p>
<p>这里建议 Tabs 使用 position:absolute 来将不可见的组件移动到用户不可见的负坐标区域，需要时再将面板移动到可见区域，
来避免面板不可见时渲染内部组件异常的问题。而且也可以做一些滑动显示的动画效果。</p>
<!-- more -->

<p>简单示例代码：</p>
<p>HTML:</p>
<div class="highlight"><pre><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tabs"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tabbar"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"active"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#tab1"</span>&gt;</span>Tab 1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#tab2"</span>&gt;</span>Tab 2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tabpanel"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"active"</span>&gt;</span>
      Tab Panel 1
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
      Tab Panel 2
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>LESS:</p>
<div class="highlight"><pre><code class="less"><span class="hljs-selector-class">.tabs</span> {
  <span class="hljs-selector-class">.tabpanel</span> {
    <span class="hljs-attribute">position</span>: relative;
    <span class="hljs-selector-tag">li</span> {
      <span class="hljs-attribute">position</span>: absolute;
      <span class="hljs-attribute">top</span>: -<span class="hljs-number">999999px</span>;
      <span class="hljs-attribute">left</span>: -<span class="hljs-number">9999px</span>;
      <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>; <span class="hljs-comment">/* 避免浮动导致宽度不对 */</span>
    }
    <span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.active</span> {
      <span class="hljs-comment">/* 不要使用 position:absolute 并且改变坐标的方式，
       * 避免 Tabs 脱离文档流，父元素高度为 0，导致下面的其他元素错位。
       */</span>
      <span class="hljs-attribute">position</span>: static;
    }
  }
}</code></pre></div><h2 id="切换-tab-时，面板所在位置问题">切换 Tab 时，面板所在位置问题</h2><p>无论使用 display 还是 position 方案，切换 tab 的时候，面板的位置会停留在上个显示的面板离开时的同一位置（默认是 0）。</p>
<p>有两个解决方案：</p>
<ol>
<li>对于可以固定面板高度的场景（如整个页面都是 Tab），固定面板容器的高度，则 position 方案在切换 Tab 的时候，
默认就定位在当前面板之前停留的位置，但是需要使用 iScroll 类似的方案来实现上下拉回弹，及刷新、加载更多的功能
（也可以使用 Native 默认的上下拉回弹功能，但是 Tabbar 会随着整个 webview 一起拉动，体验不是太好）。</li>
<li>切换 Tab 时，记录各个面板的所在位置，切换回来时使用 scrollTo(x, y) 的方式来滚动到面板上次的位置。</li>
</ol>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[使用 GPG 签名 Git Commits]]></title>
        <link href="http://blog.hotoo.me/post/gpg-sign-for-git-comments"/>
        <published>2016-06-11T00:00:00.000Z</published>
        <updated>2016-06-11T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/gpg-sign-for-git-comments</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p>前段时间 GitHub 支持在 Git Commits 中使用 GPG 签名验证，可以避免其他人使用你的
Email 进行 commit。</p>
<h2 id="安装-gpg">安装 GPG</h2><p>下载地址： <a href="https://www.gnupg.org/download/">https://www.gnupg.org/download/</a></p>
<p>Mac 下有两个可选工具，分别是 <a href="http://gpgtools.org/">Mac GPG</a> 和 GnuPG for OS X，我都尝试了下，觉得
Mac GPG 相对比较容易点，安装过程中同时引导创建一个 GPG key 存储到 GPG keychain
中，并且在 Git 提交时记住 passphrase，避免每次提交输入 passphrase。</p>
<!--more-->

<h2 id="生成-gpg-key">生成 GPG key</h2><blockquote>
<p>如果在安装过程中，自动引导生成了 GPG key 的话，这一步可以省略。</p>
</blockquote>
<p>除了安装时引导生成的 GPG key 之外，你还可以手动生成 GPG key：</p>
<div class="highlight"><pre><code class="bash">$ gpg --gen-key
gpg (GnuPG/MacGPG2) 2.0.28; Copyright (C) 2015 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Please select what kind of key you want:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sign only)
   (4) RSA (sign only)
Your selection?
RSA keys may be between 1024 and 4096 bits long.
What keysize <span class="hljs-keyword">do</span> you want? (2048)
Requested keysize is 2048 bits
Please specify how long the key should be valid.
         0 = key does not expire
      &lt;n&gt;  = key expires <span class="hljs-keyword">in</span> n days
      &lt;n&gt;w = key expires <span class="hljs-keyword">in</span> n weeks
      &lt;n&gt;m = key expires <span class="hljs-keyword">in</span> n months
      &lt;n&gt;y = key expires <span class="hljs-keyword">in</span> n years
Key is valid <span class="hljs-keyword">for</span>? (0) 1y
Key expires at 日  6/11 22:33:50 2017 CST
Is this correct? (y/N) y

GnuPG needs to construct a user ID to identify your key.

Real name: xxx
Email address: xxx@yyy.com
Comment:
You selected this USER-ID:
    <span class="hljs-string">"xxx &lt;xxx@yyy.com&gt;"</span>

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit?
Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O
You need a Passphrase to protect your secret key.

We need to generate a lot of random bytes. It is a good idea to perform
some other action (<span class="hljs-built_in">type</span> on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number
generator a better chance to gain enough entropy.
We need to generate a lot of random bytes. It is a good idea to perform
some other action (<span class="hljs-built_in">type</span> on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number
generator a better chance to gain enough entropy.
gpg: key B5DB6617 marked as ultimately trusted
public and secret key created and signed.

gpg: checking the trustdb
gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model
gpg: depth: 0  valid:   3  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 3u
gpg: next trustdb check due at 2017-06-11
pub   2048R/B5DB6617 2016-06-11 [expires: 2017-06-11]
      Key fingerprint = 3AE5 19D5 8A58 C59B B029  6CEA 8566 6A47 B5DB 6617
uid       [ultimate] xxx &lt;xxx@yyy.com&gt;
sub   2048R/1F4A9B85 2016-06-11 [expires: 2017-06-11]</code></pre></div><h2 id="配置-git">配置 Git</h2><p>配置好 GPG key 之后，可以配置让 git 在某个仓库所有的 commits 都添加 GPG key 验证：</p>
<div class="highlight"><pre><code class="bash">git config commit.gpgsign <span class="hljs-literal">true</span></code></pre></div><p>也可以让本地所有的仓库都进行 GPG 验证：</p>
<div class="highlight"><pre><code class="bash">$ git config --globall commit.gpgsign <span class="hljs-literal">true</span></code></pre></div><h2 id="验证-git-commits">验证 Git commits</h2><p>如果没有设置局部仓库或全局仓库默认开启 commits GPG 验证，提交时可以附加 <code>-S</code> 参考，
要求进行 GPG 验证。</p>
<div class="highlight"><pre><code class="bash">$ git commit -S -m <span class="hljs-string">"comment"</span></code></pre></div><p>如果提交使用的账户信息和 GPG 签名不一致，则无法通过 GPG 验证，会导致提交失败。</p>
<div class="highlight"><pre><code class="bash">$ git ci -m <span class="hljs-string">"test"</span>
gpg: skipped <span class="hljs-string">"ZZZ &lt;xxx@yyy.com&gt;"</span>: No secret key
gpg: signing failed: No secret key
error: gpg failed to sign the data
fatal: failed to write commit object</code></pre></div><p>正常的话，会提示输入 passphrase 解锁 PGP 密钥，此时可以选中保存到 Mac OS X 系统
的 Keychain 中，避免每次输入 passphrase。</p>
<div class="highlight"><pre><code class="bash">$ git add .
$ git ci -m <span class="hljs-string">"test"</span>

You need a passphrase to unlock the secret key <span class="hljs-keyword">for</span>
user: <span class="hljs-string">"xxx &lt;xxx@yyy.com&gt;"</span>
4096-bit RSA key, ID C0B176D7, created 2016-06-11

[master (root-commit) 163d909] <span class="hljs-built_in">test</span>
 1 file changed, 3 insertions(+)
 create mode 100644 README.md</code></pre></div><h2 id="将-gpg-密钥添加到-github">将 GPG 密钥添加到 GitHub</h2><p>这时 push 到 GitHub 仓库的 commits，查看 commits 记录会显示 <code>unverified</code>。</p>
<div class="highlight"><pre><code class="bash">$ gpg --list-secret-keys
/Users/xxx/.gnupg/secring.gpg
-------------------------------
sec   4096R/C0B176D7 2016-06-11 [expires: 2020-06-11]
uid                  xxx &lt;xxx@yyy.com&gt;
ssb   4096R/E00F263F 2016-06-11

$ gpg --armor --export C0B176D7
-----BEGIN PGP PUBLIC KEY BLOCK-----
Comment: GPGTools - https://gpgtools.org

****************************************************************
****************************************************************
****************************************************************
************************************************
*****
-----END PGP PUBLIC KEY BLOCK-----</code></pre></div><p>将上面 export 出来的 GPG 密钥添加到 GitHub 的 <a href="https://github.com/settings/keys">SSH and GPG keys</a> 即可。</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://github.com/blog/2144-gpg-signature-verification">GPG signature verification</a></li>
<li><a href="https://help.github.com/articles/signing-commits-using-gpg/">Signing commits using GPG</a></li>
<li><a href="https://help.github.com/articles/generating-a-new-gpg-key/">Generating a new GPG key</a></li>
<li><a href="https://help.github.com/articles/adding-a-new-gpg-key-to-your-github-account/">Adding a new GPG key to your GitHub account</a></li>
<li><a href="https://www.gnupg.org/download/">GnuPG - download</a></li>
</ul>
<h2 id="延伸阅读">延伸阅读</h2><ul>
<li><a href="https://mikegerwitz.com/papers/git-horror-story">A Git Horror Story: Repository Integrity With Signed Commits</a></li>
<li><a href="http://www.oschina.net/translate/git-horror-story">Git 使用中的教训：签名提交确保代码完整可信</a></li>
<li><a href="http://arondight.me/2016/04/17/%E4%BD%BF%E7%94%A8GPG%E7%AD%BE%E5%90%8DGit%E6%8F%90%E4%BA%A4%E5%92%8C%E6%A0%87%E7%AD%BE/">使用 GPG 签名 Git 提交和标签</a></li>
<li><a href="https://github.com/pstadler/keybase-gpg-github">Step-by-step guide on how to create a GPG key on keybase.io, adding it to a local GPG setup and use it with Git and GitHub</a></li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[测试代码和可测试代码]]></title>
        <link href="http://blog.hotoo.me/post/test-code-and-testable-code"/>
        <published>2016-06-04T00:00:00.000Z</published>
        <updated>2016-06-04T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/test-code-and-testable-code</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p>项目中有一个要将指定时间和当前时间比较，计算相对时间的逻辑（比如显示 <code>3 分钟前</code>），
由于当前时间和执行测试用例的时机有关，每次执行用例都会不同，如何让这个代码可测试呢？
有些人可能想到 Mock 当前时间，测试的时候让当前时间凝固，于是有了如下代码：</p>
<div class="highlight"><pre><code class="javascript"><span class="hljs-comment">// 实际业务代码中：</span>
<span class="hljs-comment">// 虽然本来只需要 moment() 就可以了，但是为了方便测试，传入了一个可 Mock 的 Date.now</span>
<span class="hljs-keyword">const</span> now = moment(<span class="hljs-built_in">Date</span>.now());

<span class="hljs-comment">// 测试用例中，Mock Date.now 方法：</span>
mm(<span class="hljs-built_in">Date</span>, <span class="hljs-string">'now'</span>, () =&gt; <span class="hljs-number">1464969293129</span>);</code></pre></div><p>这个业务代码是 <strong>可测试</strong> 的代码吗？我认为不是。</p>
<!--more-->

<p>这个业务代码为了测试，使用了一个不必要的方法，而且让测试代码和业务逻辑相互依赖，
一旦业务代码重构，测试代码将不可测试。这个代码是为测试写的，称之为 <strong>测试</strong> 代码
而不是 <strong>可测试</strong> 代码更合适点。</p>
<p>再举一个例子，还是时间相关的动态数据输入问题：</p>
<p>项目中有一个今日收益更新的提醒消息，只有是今天的更新才显示，所以第一直觉应该是造一个
收益更新时间是今天的测试数据，而不是造一个固定的数据（可能固定测试数据比较偷懒方便），
然后篡改业务逻辑中当前时间的计算。</p>
<div class="highlight"><pre><code class="javascript"><span class="hljs-comment">// 业务代码正常该怎么写怎么写，不用管测试怎么活。</span>
<span class="hljs-keyword">const</span> today = moment().format(<span class="hljs-string">'YYYYMMDD'</span>);
<span class="hljs-keyword">if</span> (data.updateDate === today) {
  <span class="hljs-comment">// show message.</span>
}

<span class="hljs-comment">// 活的测试数据</span>
data.updateDate = moment().format(<span class="hljs-string">'YYYYMMDD'</span>);</code></pre></div><blockquote>
<p>测试代码应该只关注正常的数据输入和输出 <em>（即使输入、输出是难以预测的）</em>。</p>
<p>而不应该关注业务实现逻辑，试图篡改业务代码，让测试可以进行。</p>
</blockquote>
<p>更好一点的可测试代码，可以将当前时间传入以便让输入、输出可以预测：</p>
<div class="highlight"><pre><code class="javascript"><span class="hljs-comment">// 业务抽象</span>
<span class="hljs-comment">// 计算两个时间差，格式化为 `3 分钟前` 等相对时间。</span>
<span class="hljs-comment">// @param {Date|Number} date1 较早的时间或时间戳。</span>
<span class="hljs-comment">// @param {Date|Number} date2 较晚的时间或时间戳，默认当前时间。</span>
<span class="hljs-comment">// @return {String} 相对时间差</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dateDiff</span>(<span class="hljs-params">date1, date2 = Date.now(</span>)) </span>{
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// 业务调用</span>
dateDiff(data.datetime);

<span class="hljs-comment">// 测试代码</span>
assert(dateDiff(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2016</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2016</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)) === <span class="hljs-string">'刚刚'</span>);
assert(dateDiff(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2016</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2016</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)) === <span class="hljs-string">'3 分钟前'</span>);
assert(dateDiff(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2016</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2016</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)) === <span class="hljs-string">'1 小时前'</span>);</code></pre></div><h2 id="2017-02-09-更新">2017-02-09 更新</h2><p>群里又有了类似的一个案例，开发想写测试用例来测 location.href 的赋值是否正确，
用以测试页面跳转逻辑是否正确。于是想通过重载 location 对象来监听给 location.href
赋值时，所赋值是否符合期望。</p>
<p>还辛苦找到 <a href="https://zhuanlan.zhihu.com/p/24342684">Chrome 出了个小 bug：论如何在 Chrome 下劫持原生只读对象</a>
这么牛逼变态到令人折服的方法。但是，这是正确的方法吗？我认为不是。</p>
<p>location 的案例中，我觉得应该是测试赋值给 location.href 的 <strong>值</strong>本身是否正确，
而不是测试企图篡改 location 来监听 href 属性是否正确。即：</p>
<div class="highlight"><pre><code class="javascript"><span class="hljs-comment">// 业务代码</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUrl</span>(<span class="hljs-params"></span>)</span>{}
location.href = getUrl(...args);</code></pre></div><p>单元测试用例只需要测试 getUrl 在各种边界输入条件下，输出是否符合期望就可以了。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[杭州购车记]]></title>
        <link href="http://blog.hotoo.me/post/buying-a-car-in-hangzhou"/>
        <published>2016-01-27T00:00:00.000Z</published>
        <updated>2016-01-27T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/buying-a-car-in-hangzhou</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p>终于在年前把车的事情搞定了，这是 2015 年做成的唯一一件大事，经历了不少坎坷，一路摸索过来，很多都是懵懂，
因此想通过这篇流水记录，帮助到一点大家，如果有写的不好不对的地方，大家可以给我提出，我尽力改进。</p>
<p>『车图』</p>
<!--more-->

<h2 id="驾照">驾照</h2><p>杭州限牌限行前，我就拿到了驾照，跟另两个同事一起在公司对面的驾校学的。</p>
<p>报名、体检、缴费、领教程学习理论知识，科目一没有拿到满分，但一次性通过了，没有补考。</p>
<p>教练在时间上安排的比较合理，科目二场地练习时，一般每周有两个工作日早上 7 点半左右到驾校练习 1 个半小时，9 点到公司上班。
（科目二包括项目：出库、倒库、移库、侧方停车、曲线行驶、停坡起步、直角转弯、单边桥、起伏路行驶等）。满分通过。</p>
<p>模拟学习，可以选择周末去坐几个小时。</p>
<p>模拟考试，尽早预约。</p>
<p>路上没开过多少次，大都是邻近考试前两天冲刺恶补，但是很快就熟悉了。
但是教练没教各种灯怎么用，只会转向灯（和刹车灯），大灯都不会。
考试时不知道怎么关双闪，好紧张，挂科一次。当场补考，很紧张慢腾腾的开，考官说这么好的路况开快点，
于是加油门、变道、超车，行云流水，把平时学车时的状态发挥出来了，满分通过。
事后同考的同事说，还好你补考 HOLD 住了，表现不错。</p>
<p>从开始学车，到拿到驾照，差不多 3 个月时间，挺快的。</p>
<h2 id="购车">购车</h2><p>老婆喜欢 SUV，汽车之家上看的也基本都是 SUV，然后去 4S 店看实体车试驾。</p>
<ul>
<li>马自达 CX-5，说实话，外观确实漂亮，操纵也非常好。但是老婆晕车，说坐着头晕。</li>
<li>奔驰 GLA，也挺漂亮，但是紧凑型偏小，早晚被换。</li>
<li>宝马 X1 紧凑型小，拥挤；X3 小贵。</li>
<li>奥迪 Q3 紧凑型有点小，坐着挤；Q5 小贵。</li>
<li>本田 XR-V，CR-V 看着、坐着都不喜欢，没试驾。</li>
<li>MINI，老婆很喜欢，但是看了评价都说避震硬垫屁股，综合评价第一辆车不合适。</li>
<li>昂克威，看起来胖嘟嘟的有点可爱，但是试驾起来还是一个胖子步态。</li>
<li>比亚迪・唐，电动车日常上下班代步还是很有优势的，不知道小区车库是否可以安装充电设备。
主要考虑到电动车目前可能还太成熟，基础设施也不够齐全。因为是混动，这个价钱可以买个
好点的传统汽油发动机的车。</li>
<li>Jeep 自由光，看车的时候正好即将推出，但是我应该是等不到了，图片看起来不错，
但是也有人说 Jeep 车不好，小毛病多。</li>
<li>随便听到公司同事在说大众高尔夫，挺牛逼的样子，虽然我不懂。但是网上一看就不是我的菜。</li>
<li>沃尔沃 XC60，驾驶感不错，车身很稳，老婆说很舒服不晕了，但是小贵。</li>
<li>顺便看了沃尔沃 S60L，总体很喜欢，但不是 SUV。</li>
</ul>
<p>最后综合多方面情况考虑，选了沃尔沃 S60L，找老婆的朋友的朋友的 4S 店朋友，拿到相对比较高的优惠。</p>
<p>小吐槽下，第一次经历买车很多东西都不懂，被坑到不少。</p>
<ul>
<li>比如车子大约是 8 个月前生产的，放了大半年。虽然是新车没错，而且据说沃尔沃车子小众
（但是买车之后我路上经常会碰到沃尔沃的车），所以一般会放的相对久点，看运气。
我建议对于放了时间长的车，如果不能接受，可以要求换车，或者提出其他要求。</li>
<li>被强制安装了导航模块，加了 2 千元左右。</li>
<li>平安银行无息免抵押贷款，本来说不需要购买盗抢险，结果说总行有新政策又要求必须买盗抢险。</li>
<li>有一次在 4S 店结果轮毂被他们蹭花。</li>
</ul>
<h2 id="临牌">临牌</h2><ol>
<li>买车时，4S 店会帮申请一张 15 天的杭州市蓝色临牌。</li>
<li>第 15 天时，自己带上身份证、车辆合格证、一致性证书、发票、交强险保单，及其复印件
到车管所申领临牌。自己最多可以申领 2 次，即有最多 45 天的杭州临牌可以用。杭州临牌
只能在杭州市辖范围内使用，不可跨市甚至跨省使用，违反被抓的话属于无牌驾驶，直接扣 12 分，扣车。</li>
<li>1 号楼拿身份证在服务台拿号等候审核资料。<ul>
<li>我第一次下午去前面有 100 人，等候了 1 小时左右。</li>
<li>第二次上午 11 点半去，本以为赶不上了，结果没什么人，直接窗户审核资料，缴费，总共 20 分钟左右拿到临牌。</li>
</ul>
</li>
<li>资料审核完备后拿到回执单缴费，每张临牌 5 元，总共 10 元。</li>
<li>缴费拿到另一张回执单等候取牌照，一般 20 分钟左右。</li>
</ol>
<h2 id="竞拍车牌">竞拍车牌</h2><ol>
<li>每月 8 日之前提交资料进行审核（3 个月有效期，到期前也是 8 号之前可以提交延长 3 个月有效期）。</li>
<li>每月 23 日公布审核结果（登录到系统中查询状态）。</li>
<li>每个月的都有竞拍日历，可以自己做个日历通知。</li>
<li>5 个工作日的缴付 2000 元的竞价保证金，可以通过银行柜台、网银转账，但不要用支付宝、微信等第三方支付工具。</li>
<li>竞价前 2 天可以激活竞价资格，设置竞价密码。</li>
<li>一般每月 25 日（遇节假日顺延至工作日）早上 9:00 ~ 15:00 直接进行报价竞拍，
11:00 和 13:00 两个整点会统计当时的均价，自行根据实际情况调整报价，每人有 2 次修改报价机会。</li>
<li>15:00 时统计出最终均价和底价等数据，可以查询自己是否中标。</li>
<li>竞拍到车牌的，下个工作日可以打印《杭州市小客车增量指标竞价收入缴款通知书》1 份，到<strong>杭州银行</strong>营业厅
缴款即可，缴款完成后，<strong>杭州银行</strong>会给一张《浙江省非税收统一票据》，放好，上牌要用。<ul>
<li>注：没有<strong>杭州银行卡</strong>的，只能使用现金缴款，另外银行 ATM 机取款好像有 2 万限额。</li>
<li>注：通知书打印比较痛苦，提示要用 Windows 在 IE 并安装了专用浏览器控件后才能打印，
但是最终使用 A4 纸打印出来的尺寸很小，我最终采用了前端工程师特有技术解决了打印结果不完美的问题。</li>
</ul>
</li>
<li>竞拍日后第 3 个工作日（一般 28 日）18:00 之后（可能会延迟数小时）就可以登录
<a href="http://xkctk.hzcb.gov.cn/">杭州市小客车总量调控管理信息系统</a> ，在底部有指标信息可以下载和打印。</li>
</ol>
<h2 id="缴税">缴税</h2><ol>
<li>上牌前需要缴购置税（中国是双向收税制度，没办法）。<code>购置税额 = 车辆官方指导价 ÷ 1.17 × 10%</code></li>
<li><p>缴税地点在杭州汽车城 6 楼的税务大厅，我早上 9 点到那边，人不多，取号就被叫号了。
审核好资料后，拿回执单到缴费窗口刷卡即可，可以用信用卡。15 分钟就办好。</p>
<p>所需材料：</p>
<ul>
<li>身份证原件、复印件。</li>
<li>合格证原件、复印件。</li>
<li>发票联、纳税联原件、复印件。</li>
<li>打印的《个人指标证明文件》</li>
</ul>
</li>
</ol>
<h2 id="选车牌号">选车牌号</h2><p>可以在网上查可选的号码，和家人朋友一起参谋选择意向车牌号码。</p>
<ul>
<li>《掌上车管》手机 App。游客模式 - 车辆业务 - 自主选号 - 同意 - 输入手机号 - 点击“获取验证码” - 可选车号查询。</li>
<li><a href="http://zzxh.zjsgat.gov.cn:6081/zjwwzzxh/tscreenquery.do?act=shownumselectquerypage&amp;fzjg=%D5%E3A">机动车号牌自主查询系统</a></li>
</ul>
<p>可以很方便的使用任意键查询可选号码，比如 <code>888**</code>。</p>
<p>选好意向车牌后，还可以在上牌前一天选号车牌号码（有效期 3 天，不要太早选号）</p>
<ul>
<li>《掌上车管》手机 App。游客模式 - 车辆业务 - 自主选号 - 同意 - 输入手机号 - 点击“获取验证码” - 自主选号。</li>
<li><a href="http://zzxh.zjsgat.gov.cn:6081/zjwwzzxh/">浙江省机动车号牌互联网自编自选系统</a> - 同意 - 手机号 - 验证码 - 确定 - ...</li>
</ul>
<h2 id="上牌">上牌</h2><p>汽车城也可以办理上牌，但是我在网上看的三墩车管所办理流程，写的很到位，再加上办理临牌时我对这边相对熟悉，所以选择了三墩车管所。</p>
<ol>
<li><p>杭州市公安局交警支队车管所（三墩车管所，古墩路 699 号）东门是不让车进的，要从南边圣苑北街进去。</p>
<p>门口很多代办的，一般要 100 元服务费（4S 店要 300 元比较黑），因为要本人在场，而且业务不是很复杂，
代办没有太多必要。</p>
</li>
<li><p>开车进南门后往前，沿入口指示牌方向右转直走到底，再右转到底就到 2 号楼门口了，排队，车轮打正，下车，
看到有拿卡片机拍照的工作人员就找他帮你拍照（4S 店提供的照片不能用）。</p>
</li>
<li>去 2 好大厅拍照的几个窗口找给你牌照的工作人员拿照片和《机动车检查记录表》，把车架号拓印贴上，照片留着办理行驶证时要用。</li>
<li>拿到后排队并把车往前挪到车棚下，打开发动机仓，解锁车门。<ul>
<li>合格证原件</li>
<li>机动车检查记录表</li>
</ul>
</li>
<li>验车的交警是一批车来检验一次，所以要等等。验车交警出来验车时，一般根据车辆停的顺序从前往后验，
但国产车和进口车验车交警不同，所以交警可能直接跳过前面的进口车。</li>
<li><p>将《检查记录表》和车辆合格证原件交给验车交警，解开前后车门锁，方便验车。交警主要检查发动机仓、
副驾驶座底下看了半天不知道看什么，副驾驶座后面的座位底下也看了下，新车一般没什么问题。</p>
<p>注：因为我的车轮毂被 4S 店刮坏了，多问了 4S 店的销售几句，说他们有个客户，因为车门撞了红色车漆花了，
产生了明显的不一致，被要求修车重新喷了新漆，所以未上牌期间开车尽量小心，避免给上牌带来麻烦。</p>
</li>
<li><p>验车 OK 之后，交警会让你把车开走，开到停车场停好，然后回到 2 号楼 1 号窗口等拿回《检查记录表》。
如果业务办理人多的话，这期间可以把其他材料放到业务办理窗口排队，后面拿到《检查记录表》后再补充进去。</p>
<ul>
<li>《检查记录表》业务办理是必须的材料，所以如果刚验好车的话，建议放在前面有 5、6 个人的窗口排队。</li>
<li>如果已经拿到了记录表，可以多看看不同的业务办理窗口，排队人数可能很不平均的。</li>
</ul>
</li>
<li>材料齐全后开始正式业务办理，把工作人员要求的材料交给她就好了，剩下的事情都交她来处理。</li>
<li>正常来说，邻近办好业务时，工作人员会给你一个选号单，可以在 2 号大厅东侧的小隔间里的选号机上进行选号。<ul>
<li>因为我事先通过手机《掌上车管》App 选好了号码，因此这一步免了，工作人员口头跟我确认了车牌号，办理好之后给个回执单。</li>
<li>另外掌上车管选号时可以选择在办理上牌的网点自取，或者邮寄。我想着过年了快递可能不给力，万一过年回家前没寄到就麻烦了，
所以选择了自取，但是工作人员告知自取要 10 个工作日后，邮寄则 3 个工作日内寄出。10 个工作日肯定来不及，因此修改为邮寄了，
将收件人姓名、手机号、收件地址写到身份证复印件背面空白处即可（可以提前写好）。</li>
</ul>
</li>
<li>去大厅东侧的缴费窗口缴费，125 元上牌费再加 10 元的金黄色全国临牌费，总共 135 元。</li>
<li>在缴费窗口旁边的窗口等待发放行驶证、登记证书、临牌。</li>
<li>旁边的另一个窗口拿环保标志。</li>
<li>收工。</li>
</ol>
<h2 id="安装车牌">安装车牌</h2><p>邮寄是 EMS 到付 10 元，市区内还是不慢的，上周五邻近中午办理好的，周一中午就收到邮寄的车牌了。
因为是防盗螺栓没装过，而且需要专用的螺丝刀，所以花 20 元请修车工作人员帮忙装好了。另外 4S 店也可以帮忙安装。
其实如果有专用螺丝刀，和安装普通螺丝没太多差别：</p>
<ol>
<li>将垫片和螺丝拧紧。</li>
<li>将螺帽用力摁进去即可。</li>
</ol>
<p>注：新的交通法规要求每块车牌安装四个螺丝，否则按照无牌判罚（12 分、扣车、罚款），
安装不是很麻烦，请人安装也不会因为这个多加钱，没必要把车管所寄给你的螺丝放那里备用。</p>
<h2 id="贴标">贴标</h2><p>车辆合格标志、环保标志、交强险标志都是要贴到前挡风玻璃上的（一般贴在右上角位置）。
直接贴玻璃上后续换新标会比较难揭下来，一般 4S 店、保险公司、网购汽车用品的商家都会附送静电贴膜，
把车标粘在静电贴膜上，再把静电贴膜贴到车窗上会比较方便。</p>
<h2 id="贴膜">贴膜</h2><p>一般防晒防紫外线，但是不宜颜色过深，否则光线暗的地方看不清后视镜，有安全隐患。
同时，2004 年 10 月 1 日实施的国家标准《机动车运行安全技术条件》（GB7258—2004）第 11.6.4 条规定，
机动车驾驶室必须保证驾驶员前方视野和侧方视野，
前挡风窗玻璃及风窗以外玻璃用于驾驶员视区部位的可见光透射比不允许小于 70%，
所有车窗玻璃不允许张贴镜面反光遮阳膜。</p>
<p>据悉，车辆进行年检时，检测人员会对车辆驾驶室的“透光率”进行检测，
一般来说，在车辆两侧玻璃上张贴反光膜的车辆都不可能通过“透光率”这个标准。</p>
<h2 id="加油卡">加油卡</h2><p>大部分加油站的营业店里都可以办理加油卡，带好身份证原件和 15 元现金作为押金即可，办好后可以当场使用信用卡充值加油。</p>
<p>淘宝有折扣充值的，9.8 折看起来不多，但每加 1 箱汽油的钱，大约可以多加 1、2 升汽油，还是挺不错的了。
支付宝等网上充值也很方便。但是因为加油卡是芯片卡，网上充值后要去圈存下比较麻烦，不过很多加油站可以自助圈存。</p>
<p>有加油卡的用户，可以自助加油。自助加油要注意安全，静电、明火要小心。</p>
<h2 id="汽车用品">汽车用品</h2><ul>
<li>盲区镜：贴在两侧后视镜上的小圆镜，我个人喜欢有万向节无边的。</li>
<li>方向盘助力器：大角度打方向盘会非常顺利。</li>
<li>手机支架：个人推荐夹在空调出风口、万向节、吸铁石的这种，小巧简洁实用。</li>
<li>空气清新剂：香水不错，固态的也行。</li>
<li>吸尘器：家用的即可，换个稍小的吸嘴。</li>
<li>免清洗抹布：自己洗车、擦个雨水污渍什么的还是很有用的，比较容易清洗。</li>
<li>后备箱或后排挂钩：挂些不能倒的东西很有用，买不到合适的也可以考虑自制。</li>
<li>对讲机：2 辆车及其以上的车队，沟通起来会比较方便，没有信号的地方也不愁。</li>
<li>陈皮糖、橙子、橘子、晕车贴：防晕车、防饿。</li>
</ul>
<h2 id="其他">其他</h2><ul>
<li>汽车之家的《用车小百科》系列不错，可以挑些自己不了解的看看，像车灯语义、山路行车注意事项等。</li>
<li>多看看交通事故视频，自己多想想什么场景应该注意什么，出现状况时应该如何正确应对等。</li>
<li>放平心态，遇到不平用喇叭或车灯提示下就好了，不要太计较。</li>
<li>不要犹豫，该快快、该慢慢；能通过毫不犹豫的快速通过，不能通过也要毫不犹豫的减速停下。</li>
</ul>
<h2 id="灯语">灯语</h2><ul>
<li>提示后车（大灯、车距等）：短暂雾灯，或危险警告灯（双跳灯）。</li>
<li>提示前车（信号灯变化、注意压线行驶、并线等）：大灯闪两次。</li>
<li>不可超车：左转向灯。</li>
<li>可以超车：右转向灯。</li>
<li>前方盲区：大灯闪一下，比如车库直角转弯处等。</li>
</ul>
<h2 id="todo">TODO</h2><p>快没电了，后面抽空再补充附图。</p>
<h2 id="参考资料">参考资料</h2><ul>
<li><a href="http://www.19lou.com/forum-464848-thread-6561443007363713-1-1.html">http://www.19lou.com/forum-464848-thread-6561443007363713-1-1.html</a></li>
<li><a href="http://www.19lou.com/forum-293-thread-19001324626574730-1-1.html">http://www.19lou.com/forum-293-thread-19001324626574730-1-1.html</a></li>
<li><a href="http://wenda.haosou.com/q/1378221335061966">http://wenda.haosou.com/q/1378221335061966</a></li>
<li><a href="http://jingyan.baidu.com/article/454316ab575e72f7a7c03a91.html">http://jingyan.baidu.com/article/454316ab575e72f7a7c03a91.html</a></li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[末尾的逗号]]></title>
        <link href="http://blog.hotoo.me/post/trailing-commas"/>
        <published>2015-08-10T00:00:00.000Z</published>
        <updated>2015-08-10T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/trailing-commas</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p><img src="../../images/trailing-commas.png" alt="trailing commas"></p>
<!--more-->

<p>早期的 JavaScript 运行环境大都不支持末尾多出来的逗号，或者会抛出异常，或者不符合期望。</p>
<p>比如：</p>
<div class="highlight"><pre><code class="javascript"><span class="hljs-keyword">var</span> obj = {
  a: <span class="hljs-number">0</span>, <span class="hljs-comment">// 抛出异常。</span>
};

<span class="hljs-keyword">var</span> arr = [
  <span class="hljs-number">0</span>, <span class="hljs-comment">// arr.length === 2</span>
];</code></pre></div><p>由于不支持尾逗号，我们以前写代码都需要手动去除尾逗号（工具最多提示你这里多了个逗号）。
因此我们增加、删除一个属性、数组项时，总是需要担心相邻项的逗号问题。</p>
<p>比如增加一项：</p>
<ul>
<li>如果被增加项是列表的最后一项，则需要给前一项（原最后一项）添加一个逗号，但被添加项本身不添加逗号。<ul>
<li>新增一项本来并不需要修改前一项，但是在非尾逗号情况下则必须做这个无本质意义的修改。</li>
<li>这很麻烦，也很容易导致错误。</li>
<li>实际你只是增加了一项，但你在 diff 中会看到又是删除项，又是增加项。review 时你就需要关注这些无谓的变更。</li>
</ul>
</li>
<li>如果被添加项不是列表的最后一项，则被添加项要加上逗号。</li>
</ul>
<div class="highlight"><pre><code class="diff"> var obj = {
<span class="hljs-deletion">-  a: 0</span>
<span class="hljs-addition">+  a: 0,</span>
<span class="hljs-addition">+  b: 1</span>
 };

 var arr = [
<span class="hljs-deletion">-  0</span>
<span class="hljs-addition">+  0,</span>
<span class="hljs-addition">+  1</span>
 ];</code></pre></div><p>删除一项也是：</p>
<ul>
<li>你本来只是要删除了最后一项，但你不得不修改前一项。麻烦，容易出问题。</li>
<li>你本来只是删除了一项，但在 diff 中也是看到又是删除，又是增加。</li>
</ul>
<div class="highlight"><pre><code class="diff"> var obj = {
<span class="hljs-deletion">-  a: 0,</span>
<span class="hljs-deletion">-  b: 1</span>
<span class="hljs-addition">+  a: 0</span>
 };

 var arr = [
<span class="hljs-deletion">-  0,</span>
<span class="hljs-deletion">-  1</span>
<span class="hljs-addition">+  0</span>
 ];</code></pre></div><p>值得高兴的是，现在的 JavaScript 运行环境、预编译工具、语法检查工具都支持了尾逗号。
一旦我们统一使用尾逗号风格：</p>
<ul>
<li>我们在增加或删除一项时，再也不需要关心相邻项了。</li>
<li>diff 看起来也更直观清爽。</li>
</ul>
<p>新增一项：</p>
<div class="highlight"><pre><code class="diff"> var obj = {
   a: 0,
<span class="hljs-addition">+  b: 1,</span>
 };

 var arr = [
   0,
<span class="hljs-addition">+  1,</span>
 ];</code></pre></div><p>删除一项：</p>
<div class="highlight"><pre><code class="diff"> var obj = {
   a: 0,
<span class="hljs-deletion">-  b: 1,</span>
 };

 var arr = [
   0,
<span class="hljs-deletion">-  1,</span>
 ];</code></pre></div><p>另外也有些语言是不需要逗号的，每一项都不需要。比如 Markdown 的列表，yml，yaml，
xml，html 等。</p>
<p>全要逗号，或者全不要逗号，他们的共同点就是<strong>一致性</strong>。这种一致性让书写和阅读都非常简洁清晰。
可维护性也更好。</p>
<p>你觉得呢？</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[gitopen, Smart partner of git, hg and svn.]]></title>
        <link href="http://blog.hotoo.me/post/gitopen"/>
        <published>2015-07-24T00:00:00.000Z</published>
        <updated>2015-07-24T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/gitopen</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p>使用 Git 的你，想必会更喜欢在终端（命令行）中使用 Git。在终端中，可以将 Git
的特性发挥的淋漓尽致。</p>
<pre>$ git co -b feat-sample
$ git add .
$ git ci -m &quot;feat(sample): Add sample commit.&quot;
$ git push origin feat-sample</pre><p>咦，我想立即提交一个 Pull/Merge Request 怎么办，还要打开浏览器，输入 Git
仓库的 URL 地址，点击进入 PR 列表，再点击新建 PR，选择 feat-sample 分支，
点击确认按钮，balabala...</p>
<p>嗯，好麻烦。</p>
<p>于是 Git 的最佳伴侣 <a href="https://github.com/hotoo/gitopen">gitopen</a> 横空出世了。</p>
<p>push 了新分支，想立即提交 PR/MR，So simple.</p>
<pre>$ gitopen pr</pre><p>她会把当前分支提交一个新的 PR。</p>
<p>如果你是使用的 GitHub，在发布了新版时可能还想写个 Release Note：</p>
<pre>$ git tag 1.0.0
$ git push origin 1.0.0
$ gitopen release new 1.0.0</pre><p>咦，有个新的想法，提交个 Issue 先：</p>
<pre>$ gitopen issue 我有个好想法</pre><p>再来个 milestone 尝尝：</p>
<pre>$ gitopen milestone</pre><p>这货支持：</p>
<ul>
<li>git, hg, svn.</li>
<li>Mac OS X, Linux, Windows.</li>
<li>GitHub (Enterprise), GitLab (CE, EE), BitBucket (Atlassian Stash), GitCafe (Enterprise) ...</li>
</ul>
<p>更多功能参考：</p>
<pre>$ npm install gitopen -g
$ gitopen @hotoo/gitopen</pre>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[git+, a hack of git, smart for you.]]></title>
        <link href="http://blog.hotoo.me/post/gitplus"/>
        <published>2015-05-27T00:00:00.000Z</published>
        <updated>2015-05-27T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/gitplus</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p>为了信息安全，公司搭建了 gitlab.company.com 管理代码，同时限制了必须使用工作邮箱
hotoo@company.com 进行提交。</p>
<p>公司 gitlab 有大大小小很多仓库，不时的需要 clone 代码下来，有时忘记设置就开始提交，
提交了几次开始 push 到 gitlab 并准备提交 MR 时发现，push 被拒绝，或者 MR 无法
自动合并，因为没有使用公司的邮箱进行提交。只好取消之前的提交操作，修改邮箱配置
之后重新提交。</p>
<p>虽然 clone 下来配置一次就可以了，但是每个仓库都需要配置，每次 clone 都需要配置，
忘记设置了需要取消之前的提交并再来一次。</p>
<p>有没有办法自动进行配置呢？</p>
<p>于是 <a href="https://github.com/hotoo/gitplus">gitplus</a> 出现了，它可以根据 git
的子操作命令，及其所在的仓库信息，自动的执行指定命令，帮助你完成一些自动化任务。
例如：</p>
<pre>post-clone:
  gitlab.company.com:
    - git config user.name hotoo
    - git config user.email hotoo@company.com
pre-commit:
  &#39;*&#39;:
    - jshint .</pre><ul>
<li>有了 gitplus，你再也不会忘记设置公司邮箱。因此也不需要取消提交再重复提交了。</li>
<li>还可以在提交前自动做校验工作。没有 gitplus 之前你只能给每个仓库设置 pre-commit hooks。</li>
<li>你也可以发挥自己的想象力，做更多其他的事情。</li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[译：Resource Timing (资源计时) 使用技巧]]></title>
        <link href="http://blog.hotoo.me/post/resource-timing-practical-tips"/>
        <published>2014-12-30T00:00:00.000Z</published>
        <updated>2014-12-30T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/resource-timing-practical-tips</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p><a href="http://www.w3.org/2010/webperf/">W3C Web 性能工作组</a> 在 2012 年给我们带来了
<a href="http://www.w3.org/TR/navigation-timing/">Navigation Timing</a>，这个 API 现在
基本上在主流浏览器上都可用。Navigation Timing 定义了一套用于测量主页面性能的
JavaScript API。例如：</p>
<div class="highlight"><pre><code class="javascript"><span class="hljs-comment">// Navigation Timing</span>
<span class="hljs-keyword">var</span> t = performance.timing,
    pageloadtime = t.loadEventStart - t.navigationStart,
    dns = t.domainLookupEnd - t.domainLookupStart,
    tcp = t.connectEnd - t.connectStart,
    ttfb = t.responseStart - t.navigationStart;</code></pre></div><!--more-->

<p>能够度量主页面的时间消耗真是太棒了，但是要诊断现实当中的性能问题，往往需要深入
到各个资源当中。所以我们拥有了更进一步的 Resource Timing （资源计时）规范，
这个 JavaScript API 提供类似 Navigation Timing 的功能，但是能精确到每一个资源的
耗时。举个例子：</p>
<div class="highlight"><pre><code class="javascript"><span class="hljs-comment">// Resource Timing</span>
<span class="hljs-keyword">var</span> r0 = performance.getEntriesByType(<span class="hljs-string">"resource"</span>)[<span class="hljs-number">0</span>],
    loadtime = r0.duration,
    dns = r0.domainLookupEnd - r0.domainLookupStart,
    tcp = r0.connectEnd - r0.connectStart,
    ttfb = r0.responseStart - r0.startTime;</code></pre></div><p>到目前为止，Chrome, Chrome for Android, Opera, IE10 和 IE11
浏览器都支持 Resource Timing，这也许超过了你的网站 50% 的流量。
这应该可以提供足够的数据，来揭示这些资源缓慢的原因。</p>
<p>使用 Resource Timing 看似很简单，但是当我在写第一个用于生产环境的 Resource Timing 代码
时，遇到了许多问题。这里我想分享一些现实当中记录 Resource Timing 指标的实用技巧。</p>
<h2 id="1-使用-getentriesbytype-quot-resource-quot-而不是-getentries">1. 使用 <code>getEntriesByType(&quot;resource&quot;)</code> 而不是 <code>getEntries()</code></h2><p>在使用 Resource Timing 来获取当前页面的资源集合的资源耗时性能对象时，许多 Resource
Timing 示例都是使用 <code>performance.getEntries()</code>，这意味着唯一的 resource timing 对象
由该调用进行返回。但是 <code>getEntries()</code> 会一并返回潜在的 <a href="http://www.w3.org/wiki/Web_Performance/EntryType">4 种类型的 timing 对象</a>：
<code>resource</code>（资源），<code>navigation</code> （导航）, <code>mark</code> （标记）, 和 <code>measure</code> （测量）。</p>
<p>这并没有造成多大问题，因为目前 <code>resource</code> 是大多数网页的唯一类型。
<code>navigation</code> 类型是 <a href="http://www.w3.org/TR/navigation-timing-2/">Navigation Timing 2</a> 的一部分，据我所知目前没有被任何浏览器所实现。
<code>mark</code> 和 <code>measure</code> 类型是从 <a href="http://www.w3.org/TR/user-timing/">User Timing</a> 规范衍生出来的，在部分浏览器中可用，
但是还没有被广泛使用。</p>
<p>也就是说，<code>getEntriesByType(&quot;resource&quot;)</code> 以及 <code>getEntries()</code> 在今天可能返回相同
的结果，但是可能 <code>getEntries()</code> 将很快返回多种性能对象的混合集合，所以最好是
使用 <code>performance.getEntriesByType(&quot;resource&quot;)</code>，你可以明确的只获取 resource
timing 对象。（感谢 <a href="http://calendar.perfplanet.com/2012/an-introduction-to-the-resource-timing-api/">Andy Davies</a> 给我解释这一点）</p>
<h2 id="2-使用-navigation-timing-测量主页面的请求。">2. 使用 Navigation Timing 测量主页面的请求。</h2><p>当通过典型的请求获取一个网页的主 HTML 文档，但是这个资源并不能通过
<code>performance.getEntriesByType(&quot;resource&quot;)</code> 得到返回，要得到这个主页面 HTML 文档
的 timing 信息，需要使用 Navigation Timing 对象（<code>performance.timing</code>）。</p>
<p>虽然不太可能，当页面上没有其他资源时，这可能会导致错误发生。
例如，刚才 Resource Timing 示例使用如下代码：</p>
<div class="highlight"><pre><code class="javascript">performance.getEntriesByType(<span class="hljs-string">"resource"</span>)[<span class="hljs-number">0</span>]</code></pre></div><p>如果一个页面唯一的资源就是主页面的 HTML 文档，然后 <code>getEntriesByType(&quot;resource&quot;)</code>
返回一个空数组，这时候应用 <code>element[0]</code> 会引起 JavaScript 异常。如果你找不到
没有引用子资源的页面，你可以试试 <a href="http://fast.stevesouders.com/">http://fast.stevesouders.com/</a></p>
<h2 id="3-小心-secureconnectionstart-的问题。">3. 小心 <code>secureConnectionStart</code> 的问题。</h2><p><a href="http://www.w3.org/TR/resource-timing/#dom-performanceresourcetiming-secureconnectionstart"><code>secureConnectionStart</code></a>
属性我们衡量 SSL 协商需要多长时间。这非常重要，我经常
看到 500 毫秒以上的 SSL 协商时间，甚至更多。<code>secureConnectionStart</code> 有 3 种
可能的值：</p>
<ul>
<li>如果该属性不可用，则必须设置为 <code>undefined</code>。</li>
<li>如果不使用 HTTPS 的，则必须设置为 0.</li>
<li>如果该属性可用，并且使用了 HTTPS，则必须设置为一个时间戳。</li>
</ul>
<p>关于 <code>secureConnectionStart</code>，有三件事情需要了解下：</p>
<p>首先，在 Internet Explorer 中，<code>secureConnectionStart</code> 的值总是 <code>undefined</code>，
因为它是不可用的（该值被埋在 <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa383630(v=vs.85\">WinINet</a>.aspx) 之下）。</p>
<p>其次，在 Chrome 中有个 BUG 会导致 <code>secureConnectionStart</code> 被错误的设置为 0 的问题。
如果获取一个资源时使用预先存在的 HTTPS 连接，则 <code>secureConnectionStart</code> 将被设置
为 0，而实际上它应该是一个时间戳。（详情请参考 <a href="https://code.google.com/p/chromium/issues/detail?id=404501">bug 404501</a> ）
为了避免这个问题，测量 SSL 协商时间时，一定要检查 <code>secureConnectionStart</code> 既不是
<code>undefined</code> 也不是 <code>0</code>：</p>
<div class="highlight"><pre><code class="javascript"><span class="hljs-keyword">var</span> r0 = performance.getEntriesByType(<span class="hljs-string">"resource"</span>)[<span class="hljs-number">0</span>];
<span class="hljs-keyword">if</span> ( r0.secureConnectionStart ) {
    <span class="hljs-keyword">var</span> ssl = r0.connectEnd - r0.secureConnectionStart;
}</code></pre></div><p>第三，规范中关于 <a href="http://www.w3.org/TR/resource-timing/#dom-performanceresourcetiming-secureconnectionstart">这一行</a>
有一些误导：“...如果当前页面的协议是 HTTPS，这个属性必须立即返回用户代理(user agent)开始握手过程的时间...”
（我的重点）。有可能当前页面是 HTTP，但仍然包含我们需要测量 SSL 协商时间的 HTTPS 资源。
规范应该改为：“...如果资源的协议是 HTTPS 协议，该属性必须立即返回用户代理开始握手过程的时间...”。
幸运的是，浏览器是使用纠正后的行为，而已就是说， <code>secureConnectionStart</code> 可用于
HTTP 页面中的 HTTPS 资源。</p>
<h2 id="4-给跨域资源添加-timing-allow-origin-http-响应头">4. 给跨域资源添加 <code>Timing-Allow-Origin</code> HTTP 响应头</h2><p>出于隐私保护的原因，在获得资源的 Resource Timing 详情时有<a href="http://www.w3.org/TR/resource-timing/#cross-origin-resources">跨域限制</a>。
默认情况下，与主页面不同域的资源，下列属性被设置为 0：</p>
<ul>
<li>redirectStart</li>
<li>redirectEnd</li>
<li>domainLookupStart</li>
<li>domainLookupEnd</li>
<li>connectStart</li>
<li>connectEnd</li>
<li>secureConnectionStart</li>
<li>requestStart</li>
<li>responseStart</li>
</ul>
<p>在某些情况下，仍然希望测量跨域资源的性能，例如，当网站使用不用域名的 CDN（例如
&quot;youtube.com&quot; 使用 &quot;s.ytimg.com&quot;），以及某些第三方资源（例如 &quot;ajax.googleapis.com&quot;）。
如果资源返回 <a href="http://www.w3.org/TR/resource-timing/#timing-allow-origin">Timing-Allow-Origin</a>
响应头，跨域资源的 timing 详情将被授权访问。这个头信息指定了被允许访问 timing
详情的（主页面）来源列表，多数情况下，会使用通配符(<code>*</code>) 允许所有来源访问。
举个例子，<a href="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js">http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js</a> 返回
的 Timing-Allow-Origin 响应头信息是：</p>
<pre>Timing-Allow-Origin: *</pre><p>当第三方添加这个响应头信息时，真是太棒了。它允许站长来统计在他们网页上使用的
第三方资源的性能。感谢 <a href="http://googledevelopers.blogspot.com/2013/12/measuring-network-performance-with.html">Ilya Grigorik</a>
报告了一些添加了这个响应头的第三方资讯，下面是一些指定了 <code>Timing-Allow-Origin: *</code>
的资源例子：</p>
<ul>
<li>Google Hosted Libraries: <a href="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js">http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js</a></li>
<li>Google+ widgets: <a href="https://apis.google.com/js/plusone.js">https://apis.google.com/js/plusone.js</a></li>
<li>Google Fonts:  <a href="http://fonts.gstatic.com/s/opensans/v9/DXI[snip...]N3Vs.woff2">http://fonts.gstatic.com/s/opensans/v9/DXI[snip...]N3Vs.woff2</a></li>
<li>Facebook widgets: <a href="http://connect.facebook.net/en_US/all.js">http://connect.facebook.net/en_US/all.js</a></li>
<li>Disqus widgets: <a href="http://go.disqus.com/embed.js">http://go.disqus.com/embed.js</a></li>
</ul>
<p>当需要访问有限制的 timing 属性时，决定统计 Resource Timing 是非常重要的。
可以通过检测（上面列出的，secureConnectionStart 除外）限制性属性是否为 0 的方式
来避免限制性问题，我总是使用 <code>requestStart</code>。下面是用于在计算详细的性能指标之前，
检测和计算限制性属性是否可用的代码片段：</p>
<div class="highlight"><pre><code class="javascript"><span class="hljs-comment">// Resource Timing</span>
<span class="hljs-keyword">var</span> r0 = performance.getEntriesByType(<span class="hljs-string">"resource"</span>)[<span class="hljs-number">0</span>],
    loadtime = r0.duration;
<span class="hljs-keyword">if</span> ( r0.requestStart ) {
    <span class="hljs-keyword">var</span> dns = r0.domainLookupEnd - r0.domainLookupStart,
        tcp = r0.connectEnd - r0.connectStart,
        ttfb = r0.responseStart - r0.startTime;
}
<span class="hljs-keyword">if</span> ( r0.secureConnectionStart ) {
    <span class="hljs-keyword">var</span> ssl = r0.connectEnd - r0.secureConnectionStart;
}</code></pre></div><p>做这些检测是非常重要的，否则，当访问这些受限属性时，你不会得到任何异常，除了
这些虚假的数据。当属性受限访问时，它们的值被设置为 0，例如 <code>domainLookupEnd - domainLookupStart</code>
翻译成 <code>0 - 0</code>，它返回一个似是而非的结果 <code>0</code>，而这可能并不是真实 DNS 查询时间。
这将导致过多的指标为 <code>0</code> 而让你过于乐观。</p>
<h2 id="5-理解-0-意味着什么。">5. 理解 0 意味着什么。</h2><p>在第 4 节当中提到，一些因为跨域导致的受限访问的 Resource Timing 属性会被设置为
0。再强调一次，在访问属性详情之前，要检查属性状态是非常重要的。
但是即使受限属性都是可访问的，度量计算的返回结果也有可能是 0，所以理解这意味着
什么非常重要。</p>
<p>例如，（假设没有访问限制）<code>domainLookupStart</code> 和 <code>domainLookupEnd</code> 的值是两个
时间戳，这两个值之差是该资源在 DNS 解析上耗时。通常情况下，一个页面中指定的域名
只有一个非 0 的 DNS 解析耗时，因为浏览器会缓存 DNS 解析，所有后续的请求都使用
这个缓存的 DNS 解析。而且由于跨页面的 DNS 解析缓存，一个页面所有的 DNS 解析
计算结果可能都是 0。关键点：DNS 解析耗时为 0 意味着资源是从缓存中读取的。</p>
<p>同样，对于指定的主机名，如果重复利用已存在的 TCP 连接，那么建立 TCP 连接（<code>connectEnd - connectStart</code>）
的耗时也会是 0。每个主机有大约 6 个独立的 TCP 连接，这表明应该有 6 个非 0 的
TCP 连接测量值，但是这个主机后续的请求将使用已存在的 TCP 连接，并且他们的
TCP 连接耗时为 0。关键点：TCP 连接耗时为 0 意味着重复使用了已存在的 TCP 连接。</p>
<p>这同样适用于计算 SSL 协商（<code>connectEnd - secureConnectionStart</code>）。这个可能
有 6 个以上的资源，但是同一主机名的所有的后续请求可能都使用同一个已存在的 HTTPS
连接，以至于它的 SSL 协商时间为 0。</p>
<p>最后，如果属性持续的为 0，这可能意味资源是从缓存中读取的。</p>
<h2 id="6-确定-304-是否被测量。">6. 确定 304 是否被测量。</h2><p>这是另一个 Chrome 稳定版（版本号 36）的 BUG，这个 BUG 在 37 版时被修复。
这个问题已经被修复了，但是由于大多数用户还是使用 Chrome 稳定版，你当前的性能
指标可能跟实际上的并不相同。这个 BUG 是：一个拥有 Timing-Allow-Origin 的跨域
页面，200 响应状态并不会考虑 304 响应状态，因此，304 响应下所有的受限属性都
将显示为 0，例如 <a href="http://stevesouders.com/tests/tao.php">这个测试页面</a>。</p>
<p>这是不应该发生的，因为从 200 响应的缓存中读取的 Timing-Allow-Origin 头信息
应该应用到 304 响应中。在 Internet Explorer 浏览器中就是这样。（可以在 IE 10
或者 11 中尝试 <a href="http://stevesouders.com/tests/tao.php">这个页面</a> 来确认。）
（感谢 <a href="https://twitter.com/ericlaw">Eric Lawrence</a> 指出这一点。）</p>
<p>这会影响你的 Chrome Resource Timing 结果如下：</p>
<ul>
<li>如果（如第 4 节所述）使用检查 0 值的方式来判断受限字段，则会跳过测量 304 响应，
也就是说值测量了 200 状态响应，但是由于 200 状态响应比 304 要慢，所以 Resource
Timing 测量总量会比实际的要大。</li>
<li>反之如果不检查受限字段为 0 的情况，会得到许多的 0 值记录，
这实际上又比 304 响应要快，这样 Resource Timing 统计结果又会过于乐观。</li>
</ul>
<p>没有简单的方式来避免这些偏见，但是好消息是这个 BUG 被修复了。另外还可以尝试做的
事情是，304 响应头中发送 Timing-Allow-Origin 头，不幸的是，流行的 Apache Web
服务器不支持在 304 响应头中发送这个头信息（查看 <a href="https://issues.apache.org/bugzilla/show_bug.cgi?id=51223">BUG 51223</a>）。
缺乏进一步证件证明第 4 节提到那些第三方资源的 304 响应头中的 Timing-Allow-Origin
可以被找到。如前所述，这些第三方资源在 200 响应头中返回 Timing-Allow-Origin 头，
但是 304 响应头中不返回 Timing-Allow-Origin 头，这真是太好了。
到 Chrome 37 成为稳定版之前，因为缺少了受限属性的细节，Resource Timing 测量结果
可能偏高或偏低。幸运的是，时间会改变一切。</p>
<h2 id="7-看看-boomerang（回旋镖）">7. 看看 Boomerang（回旋镖）.</h2><p>如果你准备写自己 Resource Timing 代码，建议你最好看看 <a href="http://www.lognormal.com/boomerang/doc/api/restiming.html">Resource Timing 插件 Boomerang</a>。
（代码在 <a href="https://github.com/lognormal/boomerang/blob/master/plugins/restiming.js">GitHub</a> 上。）
Boomerang 是 Philip Tellis 维护的一个非常流行的开源 RUM 包。他起初在 Yahoo 工作
的时候就开源了 Boomerang，而现在作为在 SOASTA 工作的商业版的一部分（mPulse），
他仍然在持续的提供维护和增强。t它的代码很清晰、简洁和健壮，并解决了上面提到的许多问题。</p>
<p>总之，Navigation Timing 和 Resource Timing 都是非常优秀的新规范，为站长了解他们
的页面性能提供了很好的支持。Resource Timing 是这两个规范中更新的一个规范，因此
还是会有一些问题待解决。这些小提示将帮助你充分的利用 Resource Timing 指标。
我建议你现在就开始监控这些指标，以理解你的网站性能，为了最关心这个问题的真实用户。</p>
<blockquote>
<p>更新：有一些第三方资源提供了 Timing-Allow-Origin 响应头，以允许站长测量这些
第三方资源的性能：</p>
<ul>
<li>Boomerang: <a href="http://c.go-mpulse.net/boomerang/CEN[snip...]YQE">http://c.go-mpulse.net/boomerang/CEN[snip...]YQE</a></li>
<li>Typekit: <a href="https://use.typekit.net/previewkits/pk-v1.js">https://use.typekit.net/previewkits/pk-v1.js</a></li>
</ul>
</blockquote>
<p/>

<blockquote>
<p>更新：<code>getEntriesByType(&quot;resource&quot;)</code> 和 <code>getEntries()</code> 不包含 iframe 页面的性能，
如果 iframe 是同源的，可以在父页面通过 <code>contentWindow.performance</code> 对象访问
这些指标。</p>
</blockquote>
<h2 id="译者补充">译者补充</h2><ul>
<li><a href="http://www.stevesouders.com/blog/2014/08/21/resource-timing-practical-tips/">Resource Timing practical tips</a> - 原文出处。</li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[译：严重混乱的 Resource Timing]]></title>
        <link href="http://blog.hotoo.me/post/serious-confusion-with-resource-timing"/>
        <published>2014-12-30T00:00:00.000Z</published>
        <updated>2014-12-30T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/serious-confusion-with-resource-timing</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <h1 id="或者说『耗时包含了-blocking-部分的时间』">或者说『耗时包含了 Blocking 部分的时间』</h1><p>用 <a href="http://www.w3.org/TR/resource-timing/">Resource Timing</a> 来同统计资源下载性能
是非常赞的方式，但不幸的是，几乎所有和我聊过的人都是使用 <a href="http://www.w3.org/TR/resource-timing/#duration-attribute"><code>duration</code> 属性</a>，
而且他们都没有意识到 <code>duration</code> 包含了 blocking 时间。结果 <code>duration</code> 时间
比实际的下载时间要长很多，超出了开发者意料之外的结果。这个问题在跨域资源中
尤为糟糕，<code>duration</code> 是唯一可用的。在这篇博文中我将解释这个问题，并提出解决方案。</p>
<h2 id="resource-timing-回顾">Resource Timing 回顾</h2><p><a href="http://www.w3.org/TR/resource-timing/">Resource Timing 规范</a> 定义了收集网页中
所有资源耗时统计的 API。现在可用于 Chrome, Chrome for Android, IE 10-11, 和 Opera。
可以通过 <code>getEntries()</code>, <code>getEntriesByType()</code> 和 <code>getEntriesByName()</code> 得到一个
<code>PerformanceEntry</code> 列表，一个 <code>PerformanceEntry</code> 对象包含以下属性：</p>
<ul>
<li><code>name</code> – URL 地址</li>
<li><code>entryType</code> – 通常是 “resource”</li>
<li><code>startTime</code> – 开始处理这个资源的时间（相对开始导航到页面时的毫秒数）</li>
<li><code>duration</code> – 处理这个资源的总耗时（毫秒）</li>
</ul>
<p>上面的属性在所有的资源中都可用，包括同域和跨域的。而同域的资源拥有另外一些可以
访问的附加属性，这些属性定义在 <code>PerformanceResourceTiming</code> 接口中。这些属性名称
很简洁清晰，完全可以见名思意，并且以时间顺序排序：</p>
<ul>
<li>redirectStart</li>
<li>redirectEnd</li>
<li>fetchStart</li>
<li>domainLookupStart</li>
<li>domainLookupEnd</li>
<li>connectStart</li>
<li>connectEnd</li>
<li>secureConnectionStart</li>
<li>requestStart</li>
<li>responseStart</li>
<li>responseEnd</li>
</ul>
<p>这里有个权威的 <a href="http://www.w3.org/TR/resource-timing/#processing-model">处理模型(processing model)</a> 图
显示了这些属性所在的各个不同阶段。备注：<code>duration</code> 相当于 <code>responseEnd - startTime</code>。</p>
<p><img src="http://www.w3.org/TR/resource-timing/resource-timing-overview.png" alt="processing model graphic"></p>
<p>如何使用 Resource Timing 的详细信息，可以参考我的文章 <a href="http://www.stevesouders.com/blog/2014/08/21/resource-timing-practical-tips/">Resource Timing Practical Tips</a> 『<a href="./resource-timing-practical-tips">译者的中文翻译</a>』</p>
<h2 id="duration-中出乎意外的-blocking-膨胀"><code>duration</code> 中出乎意外的 blocking 膨胀</h2><p>出于隐私的考虑，同源资源的 PerformanceResourceTiming 属性是受限的。（备注：
任何资源可以通过 <code>Timing-Allow-Origin</code> 响应头达到“同源”效果。）现在大约有一半
的资源是跨域的，因此 <code>duration</code> 是度量加载时间的唯一方式。而且即使是同源资源，
<code>duration</code> 也是唯一以增量方式提供的属性，大概是因为它度量了最重要的阶段。
这样一来，所有我见过的 Resource Timing 实现都以 <code>duration</code> 做为主要的性能指标。</p>
<p>不幸的是，<code>duration</code> 比下载时间要大，它包含了阻塞时间（blocking time）—— 浏览器
意识到需要下载一个资源，到这个资源实际被下载直接的时间延迟。阻塞会在几种情况时
发生，最典型的资源数量比 TCP 连接数要多的情况。大多数浏览器为每个主机开放了 6
个 TCP 连接，IE10（8个连接）和 IE11（12个连接）例外。</p>
<p>这个 <a href="http://stevesouders.com/tests/rt-blocking.php">Resource Timing 阻塞测试页面</a>
有 16 个图片，因此无论哪个浏览器都会阻塞一部分图片。每个图片被编程为在服务器
有 1 秒的延迟，这 16 个图片，每个图片都显示了 <code>startTime</code> 和 <code>duration</code>。
另外还有这个测试页面在 WebPagetest 中通过 <a href="http://www.webpagetest.org/result/141125_4T_11FT/">Chrome</a>,
<a href="http://www.webpagetest.org/result/141125_BN_11FY/">IE10</a> 和
<a href="http://www.webpagetest.org/result/141125_5K_11CB/">IE11</a> 加载的测试结果，
可以通过查看截屏来分析时序结果。注，为什么所有的图片的 <code>startTime</code> 大致都相同？
英文这个时间是浏览器解析 IMG 标签并意识到需要下载改资源的时间，由于先下载的图片
阻塞的原因，但在页面出现后，图片的 <code>duration</code> 值大约步进 1 秒左右。</p>
<h2 id="译者补充">译者补充</h2><ul>
<li><a href="http://www.stevesouders.com/blog/2014/11/25/serious-confusion-with-resource-timing/">SERIOUS CONFUSION with Resource Timing</a> - 原文出处。</li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[GitHub, GitLab, or BitBucket?]]></title>
        <link href="http://blog.hotoo.me/post/github-gitlab-or-bitbucket"/>
        <published>2014-08-03T00:00:00.000Z</published>
        <updated>2014-08-03T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/github-gitlab-or-bitbucket</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <blockquote>
<p>GitHub 是汇集了众多开源项目的闭源系统，</p>
<p>GitLab 是汇聚了较多闭源项目的开源系统。</p>
<p>-- <a href="https://twitter.com/hotoo/status/417483811212238848">@hotoo</a></p>
</blockquote>
<p>对于个人开发者，不可避免的会有私有项目的需求。</p>
<p>目前比较靠谱的私有项目托管服务有：</p>
<ul>
<li>GitHub</li>
<li>GitLab</li>
<li>BitBucket</li>
</ul>
<p>下面我们稍做评比。</p>
<!--more-->

<h2 id="github">GitHub</h2><p>GitHub 当下大红大紫，主要在于其社交性质。</p>
<p>对于开源项目来说，上面大量的开发者参与带来了非常活跃的开发氛围。</p>
<p>但是对于私有仓库来说，个人觉得价格偏贵（屌丝气质暴露）。</p>
<p>而且个人账户下的私有仓库，不能共享给个人所拥有的团队账户，因此如果团队账户需要
私有仓库，则需要另外再为团队账户购买。</p>
<p>如果不缺钱，可以考虑 GitHub，甚至还有 Enterprise 版本。</p>
<h2 id="gitlab">GitLab</h2><p>GitLab 是当下最火的 Git 仓库管理的开源项目，有提供的 <a href="https://gitlab.com/">gitlab.com</a>
服务，同时可以自行部署。</p>
<p>gitlab.com 服务可以创建不限数量的私有仓库，除了少量的缺点外，GitLab 几乎可以
媲美 GitHub。</p>
<p>但是，作为完美主义者，真的受不了 GitLab 的一些小伤疤。</p>
<h2 id="bitbucket">BitBucket</h2><p>BitBucket 是 <a href="https://www.atlassian.com/">Atlassian</a> 公司的产品
（还有 Confluence，JIRA， HipChat 等著名产品）。</p>
<p>个人觉得除了 Issues 不够简洁之外，其他都很完美。
适合小团队私有项目托管。</p>
<h2 id="对比">对比</h2><table>
<thead>
<tr>
<th></th>
<th>GitHub</th>
<th>GitLab</th>
<th>BitBucket</th>
</tr>
</thead>
<tbody>
<tr>
<td>私有仓库</td>
<td>收费<br/>教育身份赞助 2年的 Micro Plan</td>
<td>免费，无限制</td>
<td>免费，限制协作人数</td>
</tr>
<tr>
<td>权限控制</td>
<td>个人账户无控制<br/>团队账户有限控制</td>
<td>仓库级控制<br/>指定一个保护分支</td>
<td>分支级控制</td>
</tr>
<tr>
<td>Transfer</td>
<td>完美</td>
<td>几乎完美</td>
<td>完美</td>
</tr>
<tr>
<td>仓库重命名</td>
<td>完美</td>
<td>不能修改 clone 地址</td>
<td>完美</td>
</tr>
<tr>
<td>仓库名</td>
<td>完美</td>
<td>不能使用 <code>.</code>，自动修改为 <code>-</code></td>
<td>完美</td>
</tr>
<tr>
<td>Issues</td>
<td>完美</td>
<td>功能复杂，但界面简洁<br/>早期有 Issues ID 缺陷，已修复</td>
<td>功能复杂，界面不够简洁</td>
</tr>
<tr>
<td>Issues URL</td>
<td>完美</td>
<td>完美</td>
<td>默认附加可选的标题信息</td>
</tr>
<tr>
<td>Pages</td>
<td>username.github.io 仓库<br/>gh-page 分支</td>
<td>demo 分支</td>
<td>username.bitbucket.org 仓库</td>
</tr>
<tr>
<td>自定义域名</td>
<td>每个仓库都可以自定义域名</td>
<td>无</td>
<td>个人 Profile 页</td>
</tr>
</tbody>
</table>
<h2 id="小结">小结</h2><ul>
<li>GitHub 适合开源项目管理。不缺钱的同学，私有项目也适合统一在 GitHub 管理。</li>
<li>GitLab 和 BitBucket 都很适合私有项目的管理。</li>
<li>GitLab 是开源项目，活跃程度很高，未来很有潜力，如果不在乎那些小硬伤，个人更推荐 GitLab。</li>
<li>BitBucket 系出名门，产品本身也非常好，没有明显的伤疤，作为完美主义者，我目前稍喜欢这个。</li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[定位到服务器集群的特定节点]]></title>
        <link href="http://blog.hotoo.me/post/find-nodes-from-server-cluster"/>
        <published>2014-04-17T00:00:00.000Z</published>
        <updated>2014-04-17T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/find-nodes-from-server-cluster</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <blockquote>
<p>齐宣王使人吹竽，必三百人。南郭处士请为王吹竽，宣王说之，廪食以数百人。
宣王死，湣王立，好一一听之，处士逃。</p>
<p>《韩非子·内储说上》</p>
</blockquote>
<h2 id="背景">背景</h2><p>某日，突然收到报警，某发现实时异常监控趋势图上，静态资源 404 异常有明显的上升。
分析详细的异常信息发现是某个发布操作引起某几个系统引起的。</p>
<!--more-->

<hr>
<p>找到对应的开发，分析结论是部分配置文件未生效，导致拼接资源文件地址错误。
按照业务量计算，这个异常量大约是其中一、两台机器有问题。</p>
<p>可能发布系统或其他问题，重新发布一次仍没能修复这个异常。</p>
<p>我们需要快速定位到这只滥竽，尽快将问题修复。
但是实际上却没有这么简单，我们最终花费 了 7个多小时，最终是因为这个系统正好有
其他发布才顺便解决。</p>
<p><img src="https://i.alipayobjects.com/i/localhost/png/201404/2TD6uw5N0n.png" alt="realtile-error-trend"></p>
<p>上图有两个造成异常的发布，分别是『CMS 发布』和『后台系统发布』。</p>
<p>橙色是 JavaScript 实时异常，绿色是静态资源 404 异常。</p>
<h2 id="方案">方案</h2><p>事后我们坐下来讨论如何解决这个问题，避免在以后遇到类似问题时能快速有效的应对。</p>
<p><img src="https://i.alipayobjects.com/i/localhost/png/201404/2Tdj3TmMdR.png" alt="异常过程序列图"></p>
<p>如上图，问题出在某个问题业务应用服务器节点配置文件未生效，拼接出来的 JavaScript
资源地址不正确导致 CDN 节点未命中而最终回源，源服务器也没有这个文件，最终发生
404 悲剧。</p>
<p>实际的业务系统中，会提供用户访问的节点信息，但是请求静态资源时无法获得这个信息，
是不是有办法在静态资源源服务器上获得来源页面所在的服务器节点信息呢？</p>
<ol>
<li>方案一：我们首先想到 Cookie。但是应用服务器和静态资源服务器分别在不同的域名
下，即使在访问应用服务器时写入节点信息到 Cookie 中，这个信息也不会携带到静态
资源服务器。『失败』。</li>
<li>方案二：CDN 节点域提供外部写 Cookie 的接口，用户访问应用服务时，同时调用接口
在 CDN 节点所在域写入用户访问应用服务器节点信息。『放弃』，缺点：<ol>
<li>成本高。</li>
<li>风险大。</li>
</ol>
</li>
<li>方案三：然后想到每个应用系统重写静态资源地址，在地址中携带当前应用服务器节点
信息。『放弃』，缺点：<ol>
<li>成本过高。</li>
<li>导致 CDN 命中率下降。</li>
</ol>
</li>
<li><p>方案四：重写用户访问页面地址，附带应用服务器节点信息。成本过高，『放弃』。</p>
<p>从前端角度直接解决这个看似无望，换个思路。</p>
</li>
<li><p>方案五：在网络内部，使用内部代理。如 <code>curl -I -x internal-host:port url</code>
『可行』，缺点：</p>
<ol>
<li>需要在服务器所在内网执行，指定目标服务器内部 IP，因此只有系统管理员可以操作。</li>
<li>而系统管理员不清楚实际应用业务。</li>
</ol>
</li>
<li><p>方案六：如果可以在外部指定服务器节点访问应用，是不是可行呢？</p>
<p>这个跟负载均衡规则有关，如果负载均衡服务器支持这个特性，或可一试。</p>
<p>跟相关同学沟通后，表示可以做。而且从外网直接访问，清楚业务的开发同学可以自行
排查。</p>
<p>『可行』。需要注意的问题：</p>
<ol>
<li>逐个击破，定向攻击。<ol>
<li>可以通过拒绝频繁的指定节点访问请求来防范。</li>
<li>可以通过白名单内部 IP 才可以使用。</li>
</ol>
</li>
</ol>
</li>
<li>方案七：客户端脚本扫描所有外部资源，并发起请求来确认各个资源状态。『放弃』，
缺点：<ul>
<li>增加静态资源服务器压力。</li>
<li>增加网络请求和流量。</li>
</ul>
</li>
<li>方案八：客户端脚本监听静态资源异常事件。HTML5 现在提供了 Performance Timing
API，可以用来监控网页及其引用的外部资源加载时间，将来提供类似的 API 可以监听
静态资源的 error 事件也未可知。『期待』</li>
<li>方案九：Web 服务器端输出时拦截器扫描。尤其目前前端往后端延伸，能做的事情更多
了。『可行』。</li>
</ol>
<h2 id="结论">结论</h2><p>综上所述，在成本、风险、自动化、扩展性等方面来讲，方案九是最优的。</p>
<h2 id="延伸思考">延伸思考</h2><p>图二所示，这次问题出在业务应用服务器集群的节点 1。</p>
<ul>
<li>如果问题节点是静态资源 CDN 集群的节点 2 呢？</li>
<li>问题节点是节点 3？</li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[转换 Vimwiki 为 Markdown]]></title>
        <link href="http://blog.hotoo.me/post/convert-vimwiki-to-markdown"/>
        <published>2014-03-31T00:00:00.000Z</published>
        <updated>2014-03-31T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/convert-vimwiki-to-markdown</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <blockquote>
<p><code>sed -f ex -i *.md</code></p>
</blockquote>
<h2 id="readme">README</h2><p>相对 Wiki 语法，和 Wiki 对应工具支持情况，我更加喜欢 Markdown 了。
本地配合使用 Vimwiki 来编辑查看，发布使用 nico 来转换，而且有 Github 的原生支持，
使用 Markdown 是不二之选。</p>
<p>为了减少转换工作量，我简要写了这个脚本，可以初步将 vimwiki 语法的项目，
自动转换成 markdown 语法。</p>
<!--more-->

<p>转换的内容包括：</p>
<ul>
<li>header</li>
<li>codes</li>
<li>wikiword.</li>
<li>links</li>
<li>images</li>
<li>comments</li>
<li>%toc</li>
<li>%title</li>
<li>%nohtml</li>
</ul>
<h2 id="usage">Usage</h2><p>假设上面的脚本保存结构如下：</p>
<pre>/
|- convert.sh
|- ex
|- vimwiki/
  |- index.wiki
  `- vim.wiki</pre><p>在 convert.sh 同级目录执行：</p>
<pre>$ ./convert.sh vimwiki/*.wiki</pre><p>然后自动或手动调整之后，删除 <code>.wiki</code> 文件即可。</p>
<h2 id="codes">Codes</h2><h3 id="convert-sh">convert.sh</h3><div class="highlight"><pre><code class="bash"><span class="hljs-meta">#!/usr/bin/env bash
</span>
<span class="hljs-keyword">for</span> x
<span class="hljs-keyword">do</span>
  filename=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$x</span>|sed <span class="hljs-_">-e</span> <span class="hljs-string">"s/\.wiki$/.md/"</span>)
  sed <span class="hljs-_">-f</span> ex <span class="hljs-variable">$x</span> &gt; <span class="hljs-variable">$filename</span>
<span class="hljs-keyword">done</span></code></pre></div><h3 id="ex">ex</h3><pre>s/# \(.*\)$/* \1/g
s/^= \(.*\) =$/# \1/g
s/^== \(.*\) ==$/## \1/g
s/^=== \(.*\) ===$/### \1/g
s/^==== \(.*\) ====$/#### \1/g
s/^===== \(.*\) =====$/##### \1/g
s/^====== \(.*\) ======$/###### \1/g
s/{{{class=&quot;brush: *\([^&quot;]*\)&quot;/\`\`\`\1/g
s/{{{class=&quot;\([^&quot;]*\)&quot;/\`\`\`\1/g
s/{{{/\`\`\`/g
s/}}}/\`\`\`/g
s/\[\([^] ]\{1,\}\)\]\([^](]\)/![pic](\1)\2/g
s/\[\([^] ]\{1,\}\)\]$/![pic](\1)/g
s/\[\[\(\([^|]\{1,\}\)\|\)\([^]]\{1,\}\)\]\]/[\3](\2.md)/g
s/\[\[\([^]]\{1,\}\)\]\]/[\1](\1.md)/g
s/\[\(https\{0,1\}:\/\/[^ ]*\) \([^]]*\)\]/[\2](\1)/g
s/%% \(.*\)/&lt;!-- \1 --&gt;/g
/%toc.*/d
s/%title \(.*\)/# \1/g
s/%nohtml/- status: draft/g</pre>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[阿里巴巴三年醇]]></title>
        <link href="http://blog.hotoo.me/post/alibaba-3-years"/>
        <published>2014-02-25T00:00:00.000Z</published>
        <updated>2014-02-25T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/alibaba-3-years</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p>今天 <a href="https://github.com/lifesinger">@玉伯</a> 给我送来的三年醇礼物。</p>
<p>一个阿里真棒玉坠。</p>
<p><img src="https://f.cloud.github.com/assets/143572/2257303/db0a08fa-9e16-11e3-90b3-5b9cea307a2a.png" alt="阿里真棒"></p>
<!--more-->

<p>三周年成（阿里）人手印礼。</p>
<p><img src="https://f.cloud.github.com/assets/143572/2257320/2a17e296-9e17-11e3-98f8-6a45a91ffcf5.png" alt="手印礼"></p>
<p>和女朋友一起用手印礼多出来的印泥自制的小猪猪。</p>
<p><img src="https://f.cloud.github.com/assets/143572/2257321/37011bda-9e17-11e3-9f28-36c0391f505a.png" alt="印泥手工制品"></p>
<p>感谢阿里。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[中国农历]]></title>
        <link href="http://blog.hotoo.me/post/lunar-calendar"/>
        <published>2013-11-13T00:00:00.000Z</published>
        <updated>2013-11-13T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/lunar-calendar</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p>Google 日历内置了中国农历的支持，但是各种桌面客户端如 Mac iCal, iPhone 默认日历
都无法正常使用，网上搜索了一遍也没有更好的订阅地址，大都不更新了。</p>
<p>而且我又不想装各种乱七八糟的第三方日历应用。</p>
<p>因此我自己制作了一个公开农历日历，需要的同学可以订阅到 Google Calendar，并且在
Google Calendar 中可以隐藏这个日历，只是在各个客户端中显示即可。</p>
<p>不过不爽的是，客户端不能针对特定日历设置提醒，有更好的方案的同学欢迎指教哈。</p>
<!--more-->

<h2 id="启用-google-calendar-内置农历（推荐）">启用 Google Calendar 内置农历（推荐）</h2><ol>
<li><p>设置(Settings)</p>
<p><img src="../../images/google-calendar-settings.png" alt="Settings"></p>
</li>
<li><p>基本(General)</p>
</li>
<li><p>备用日历(Alternate calendar)</p>
<p><img src="../../images/google-calendar-settings-alternate-calendar.png" alt="Alternate calendar"></p>
</li>
<li><p>选择 <code>农历 - 简体中文</code> (<code>Chinese calendar - Simplified Chinese</code>)</p>
</li>
<li>保存(Save)</li>
<li><p>最终可以在每日的日历顶部，有对应农历的显示。</p>
<p><img src="../../images/google-calendar-lunar-calendar-demo.png" alt="农历月历演示"></p>
</li>
</ol>
<hr>
<p>Google 日历的这个特性真是太赞了，以前为每天创建一个全天日历的挫 B方案没脸比。</p>
<p>不过，现有的桌面（包括移动设备）应用中，都没能很好的支持这个特性。我又不想安装
第三方的乱七八糟的日历应用，希望一个日历应用管理所有的日历数据，希望数据是开放的。</p>
<p>因此挫 B 的方案只能继续。</p>
<p>通过互联网在整个世界找了一圈，分享出来的农历订阅日历都已经失效、或者不更新了，
因此我决定自己来维护世界和平，创建并分享了下面的中国农历，大家只需要订阅
到自己的日历中就可以了。</p>
<h2 id="订阅地址">订阅地址</h2><ul>
<li><a href="https://www.google.com/calendar/ical/896414ier7cs228f2fp4mkn02g%40group.calendar.google.com/public/basic.ics">ical</a></li>
<li><a href="https://www.google.com/calendar/feeds/896414ier7cs228f2fp4mkn02g%40group.calendar.google.com/public/basic">xml</a></li>
<li><a href="https://www.google.com/calendar/embed?src=896414ier7cs228f2fp4mkn02g%40group.calendar.google.com&amp;ctz=Asia/Shanghai">html</a></li>
</ul>
<h2 id="订阅方法">订阅方法</h2><p>桌面应用本身支持直接订阅 ical 日历，但是为了便于管理，我统一使用了 Google Calendar
管理我的日历，桌面应用只是客户端，数据来源于 Google Calendar。</p>
<ul>
<li><p>Other calendars 右侧的菜单，选择 <code>Add by URL</code></p>
<p><img src="../../images/google-calendar-add-by-url.png" alt="Add Calendar"></p>
</li>
<li><p>填入 ical 地址：</p>
<p><code>https://www.google.com/calendar/ical/896414ier7cs228f2fp4mkn02g%40group.calendar.google.com/public/basic.ics</code></p>
<p><img src="../../images/google-calendar-add-calendar.png" alt="Add Calendar"></p>
</li>
<li><p>点击 Add Calendar 按钮。</p>
</li>
<li>由于 Google Calendar 本身内置了农历的支持，可以在 Google Calendar 中隐藏不显示这个日历。</li>
</ul>
<p>预览：</p>
<iframe src="https://www.google.com/calendar/embed?height=600&amp;wkst=1&amp;bgcolor=%23FFFFFF&amp;src=896414ier7cs228f2fp4mkn02g%40group.calendar.google.com&amp;color=%23875509&amp;ctz=Asia%2FShanghai"
  style=" border-width:0 " width="800" height="600" frameborder="0" scrolling="no"></iframe>

<h2 id="其他">其他</h2><ul>
<li>如果在使用过程中发现其中的错误，请邮件给我。</li>
<li>同时欢迎 Fork 这个 <a href="https://github.com/hotoo/chinese-lunar-calendar">『中国农历』开放项目</a> 。
或者给我们提交 Issues。</li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[Vim Talk in 来往扎堆]]></title>
        <link href="http://blog.hotoo.me/post/vim-talk-laiwangzhadui"/>
        <published>2013-10-23T00:00:00.000Z</published>
        <updated>2013-10-23T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/vim-talk-laiwangzhadui</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <blockquote>
<p>首先感谢支持加我的『来往』好友们，你们太让人感动了。</p>
</blockquote>
<p>经过一阵狂热，下面开始冷静正常的使用来往，好好利用这个应用。</p>
<p>扎堆是一个类似贴吧、论坛类信息分享交流的移动平台。
大家可以在这里随时随机的分享话题、信息、图片等，
也可以对他人发起的话题进行回复交流。</p>
<p><img src="/images/vim-talk-laiwangzhadui.png" alt="二维码"></p>
<p>欢迎加入 Vim Talk 扎堆，一起聊些有用有趣的技术话题。</p>
<p>加入方法：</p>
<ol>
<li>安装并启动 <a href="https://www.laiwang.com/">来往</a> 客户端。</li>
<li>打开『通讯录』-『添加好友』-『扫一扫加好友』-扫描上面的二维码即可。</li>
</ol>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[不缓存 CDN 静态资源方案]]></title>
        <link href="http://blog.hotoo.me/post/no-cache-in-cdn"/>
        <published>2013-09-21T00:00:00.000Z</published>
        <updated>2013-09-21T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/no-cache-in-cdn</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <h2 id="背景">背景</h2><p>支付宝目前使用淘宝提供的 CDN 服务，这个服务中的 CDN 节点在自身找不到对应资源时
主动到源服务器拉取的策略。</p>
<p><img src="/images/no-cache-in-cdn.png" alt="图"></p>
<p>支付宝使用的静态资源合并(combo)方案，导致在不同的访问参数情况下，被认为是不同
的静态资源。如果挟带的是避免缓存的随机参数，CDN 在没有缓存这个资源的情况下，
会到源服务器拉取资源。</p>
<p>原则上，我们使用特定的版本机制，每个新版本文件以不同的文件名发布，不允许使用
参数，尤其是随机数方式避免缓存问题。</p>
<h2 id="问题">问题</h2><p>由于我们使用的版本策略，我们可以指定用户缓存静态资源时效为永久，实际方案上
我们指定用户缓存时间为 1年，但是在某些场景下（如测量用户网络速度），
用户客户端（非 CDN 节点）访问某些特定静态资源需要禁止使用缓存。</p>
<p>目前常见的方案都是在客户端使用时间戳+随机数。这个方案本身看似没什么问题，但是
实际上有非常大的隐患，测量的数据参考性也不佳。</p>
<ul>
<li>CDN 节点上缓存了大量挟带永不重复随机数的资源，对磁盘造成影响。</li>
<li>CDN 缓存命中率降低，这些挟带随机数的静态资源缓存率命中率为 0。</li>
<li>增加源服务器的访问压力。</li>
<li>测量的用户网络响应时间实际不是到 CDN 节点的，还包含 CDN 回源的时间。</li>
</ul>
<!--more-->

<h2 id="解决方案">解决方案</h2><p>为了解决这种明确不允许用户客户端缓存，同时又不建议使用随机参数访问的需求，我们
有以下几种方案：</p>
<ol>
<li><p>CDN 服务器端控制浏览器不缓存。『最佳方案』</p>
<p>设置指定目录下的静态资源禁止缓存头信息，有需要禁止缓存需求时上传静态资源到
这个目录。</p>
</li>
<li><p>直接访问源服务器。</p>
<p>现在的加随机数访问 CDN 方案和直接访问源服务器本质上相同，这方案只能测用户到
源服务器的响应时间。</p>
</li>
<li><p>使用有限随机数方案。</p>
<p>虽然第一种是最佳方案，但也不排除某些浏览器或壳在不关闭页面情况下，有缓存的
问题，所以这和第一种方案结合使用可能是更靠谱一些的方案。『待验证』</p>
<p>页面脚本请求静态资源时，带上从零递增的参数，避免单页面缓存问题，亦可避免
CDN 缓存大量无意义资源的问题。</p>
</li>
</ol>
<h2 id="延伸">延伸</h2><p>实际上，对于静态资源来说，纯粹的参数是无意义的，CDN 节点本可以忽略这个参数。
虽然合并策略使用了参数方式，但是我们使用双问号激活合并服务的方案可以让我们
明确区分出合并参数和其他参数，因此技术上是完全可以忽略其他参数导致的回源。</p>
<h2 id="参考">参考</h2><ol>
<li><a href="http://segmentfault.com/q/1010000000119794">拉取式相比推送式的对比的参考</a></li>
</ol>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[每周异常：第 9期，搜狗浏览器中神一样的 try/catch 特性]]></title>
        <link href="http://blog.hotoo.me/post/weekly-topic-about-exceptions-9"/>
        <published>2013-09-13T00:00:00.000Z</published>
        <updated>2013-09-13T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/weekly-topic-about-exceptions-9</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <h2 id="背景">背景</h2><p>某日 16时 30分，监控实时大盘中全站 JavaScript 异常和 404 异常分别朝着不同的方向延伸，
橙色的 JavaScript 异常急剧上升。</p>
<p><img src="https://f.cloud.github.com/assets/143572/1136611/435cbfac-1c48-11e3-8856-8fc7ef13ce5a.png" alt="bac3c01389cadbb12d4873520b3bd2a9"></p>
<p>详细数据中我们看到一向高标准高质量的收银台出现异常大量的异常。</p>
<p><img src="https://f.cloud.github.com/assets/143572/1136701/ae74db38-1c4a-11e3-9d2d-1101c0b61a79.png" alt="2013-09-13 4 00 58"></p>
<h2 id="排查">排查</h2><p>我们发现其中有两个页面异常最多，而这两个页面中异常最多的『一个异常』详情如下：</p>
<ul>
<li>File: 同页面 URL</li>
<li>Line: 1</li>
<li>Message: Uncaught SyntaxError: Unexpected token a</li>
</ul>
<p>客户端信息：</p>
<ul>
<li>pc/-1;windows/5.1;sg/2.x;webkit/535.1</li>
<li>pc/-1;windows/6.1;sg/2.x;webkit/535.1</li>
</ul>
<p>堆栈信息：</p>
<pre>at function parse()
    at function ()
    at function (data)
    at function ()
    at function ()</pre><p>分析过程非常艰辛，重现异常的过程也是一波三折，这里不做赘述，最终分析得出：</p>
<ul>
<li>搜狗浏览器的 userAgent 太坑爹，几乎所有版本都是 2.x，开发者太不专业了。最终找到内核为 webkit/535.1 的是 3.2 版。</li>
<li><p>重现到老版 arale 中的 ajax 模块中对 JSON 有特殊的处理，如果浏览器内置的 JSON 不支持非标准的 JSON （如 <code>{a:1}</code>）则 hack 做兼容。</p>
<div class="highlight"><pre><code class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">W3CParse</span>(<span class="hljs-params">data</span>) </span>{
        <span class="hljs-keyword">if</span> (validJSON(data)) {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.JSON.parse(data)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            arale.error(<span class="hljs-string">"Invalid JSON: "</span> + data)
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defaultParse</span>(<span class="hljs-params">data</span>) </span>{
        <span class="hljs-keyword">if</span> (validJSON(data)) {
            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">"return ("</span> + data + <span class="hljs-string">")"</span>))()
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            arale.error(<span class="hljs-string">"Invalid JSON: "</span> + data)
        }
    }
    <span class="hljs-keyword">var</span> ok_wrong_json = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">try</span> {
            <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">"{ a: 1 }"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        } <span class="hljs-keyword">catch</span> (x) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }
    };
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.JSON &amp;&amp; <span class="hljs-built_in">window</span>.JSON.parse &amp;&amp; ok_wrong_json()) {
        parseJSON = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
            <span class="hljs-keyword">return</span> W3CParse.call(<span class="hljs-keyword">this</span>, data)
        }
    } <span class="hljs-keyword">else</span> {
        parseJSON = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
            <span class="hljs-keyword">return</span> defaultParse.call(<span class="hljs-keyword">this</span>, data)
        }
    }</code></pre></div></li>
<li>抛出异常的代码是 <code>JSON.parse(&quot;{a: 1}&quot;)</code></li>
<li>但奇怪的是这段代码是放在 try/catch 中，为什么还会有异常被监控捕获？</li>
<li>最终发现这是搜狗浏览器 3.2版极速(webkit)模式中的特性：即使 try/catch 住的异常，
同样会被 window.onerror 捕获，但并未因此中断业务逻辑，后续的代码仍然会按照正确的
try/catch 异常处理流程进行，所以对业务本身没有影响。</li>
<li>p.s. 搜狗浏览器没有控制台，用户不会知道出了异常。</li>
<li>另外收银台之前异常量少的主要原因是主要的页面没有引入前端监控，用户抛出了异常而我们不知道而已。</li>
</ul>
<h2 id="相关截图">相关截图</h2><p><img src="https://f.cloud.github.com/assets/143572/1136977/316cd2d8-1c51-11e3-9f7e-4bbebec06108.png" alt="2013-09-13 4 39 14">
<img src="https://f.cloud.github.com/assets/143572/1136980/32da28aa-1c51-11e3-8dc4-5773fc84f885.png" alt="2013-09-13 4 39 33">
<img src="https://f.cloud.github.com/assets/143572/1136981/331bb9f0-1c51-11e3-93bf-8cd2dcdf5d7f.png" alt="2013-09-13 4 40 26">
<img src="https://f.cloud.github.com/assets/143572/1136982/331f90c0-1c51-11e3-8d08-8d61c08512dc.png" alt="2013-09-13 4 40 12">
<img src="https://f.cloud.github.com/assets/143572/1136983/332ad480-1c51-11e3-991f-b4b0db932f69.png" alt="2013-09-13 4 41 03"></p>
<h2 id="解决方案">解决方案</h2><p>最初虽然有些争议，但我们最终决定的处理方案是监控中临时排除 sg/2.x|webkit/535.1 中
<code>Uncaught SyntaxError: Unexpected token a</code> 异常。</p>
<h3 id="是否要排除这个浏览器中所有的异常？">是否要排除这个浏览器中所有的异常？</h3><p>呃，考虑到搜狗浏览器的份额，我们的策略是只排除已知的异常，未知的异常看最终分析结果再考虑。</p>
<h2 id="广告">广告</h2><p>这个异常排查的主要功臣 @wsvn53，我们在排查过程中频繁使用了他开发的工具
<a href="https://github.com/wsvn53/fedit">Fedit</a>，可以直接修改线上代码。
排查线上故 障、线下接⼝什么的都非常⽅方便。强烈建议⼤家都装上⽤用。</p>
<h2 id="最后">最后</h2><p>我仅代表我自己，想说某些毫无责任心的国产浏览器壳厂商们，你们没有创造价值，
只是在各种不同方式的索取。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[每周异常：第 8期，异常象限]]></title>
        <link href="http://blog.hotoo.me/post/weekly-topic-about-exceptions-8"/>
        <published>2013-09-05T00:00:00.000Z</published>
        <updated>2013-09-05T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/weekly-topic-about-exceptions-8</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p>上周的 <a href="weekly-topic-about-exceptions-7">每周异常：第 7期，保持简单，保持拙朴</a>
中介绍了通过页面关键的 URL/ID 信息，简单有效的发现异常的方案。
本周我们在这个异常分析方法之上，再稍微深入下：</p>
<p>对于整个网站来说，每个系统、页面是有重要级别的，比如支付宝收银台就是 A1 级系统。
这些系统、页面一般可以按照以下方法来判断重要性：</p>
<ul>
<li>访问量极大，是最主要的业务，对用户影响极大。</li>
<li>用户本身重要（例如商户，尤其是大商户），是最重要的业务，对企业影响巨大。</li>
</ul>
<p>对于前者，我们可以通过系统、域名的访问量来近似的划分；
对于后者，我们可以建立白名单机制。</p>
<p>对于异常来说，可以通过异常率来判断异常自身的紧急程度。</p>
<hr>
<ul>
<li>系统、页面重要性作为『异常重要性』的一个指标。</li>
<li>异常率及异常量作为『异常紧急程度』作为一个指标。<ul>
<li>异常率超过阈值的为高发率异常。</li>
<li>（可选）异常量超过阈值的也是高发量异常。</li>
<li>并且以高发率为主。</li>
</ul>
</li>
</ul>
<p>我们画出以下异常象限：</p>
<p><img src="/static/images/quadrant.png" alt="异常象限"></p>
<ul>
<li>图中一、二、三、四为象限代号。</li>
<li>(0, 1, 2, 3) 为异常重要性序号。</li>
</ul>
<p>经过一些分析，我们可以得出结论：</p>
<ul>
<li>第一、第二象限的异常，是我们最需要关注的部分。尤其是第一象限的异常，
实时高发异常一般也是在这个象限。</li>
<li>第四、三象限的低发异常，则几乎可以不用关注。</li>
<li>总之我们只需要关注高发异常，但应该以页面的重要性来排优先级。</li>
</ul>
<h2 id="如何设定阈值？">如何设定阈值？</h2><p>要确定异常象限，确定各个阈值是关键，这里只提供一些简单的参考。</p>
<ul>
<li>重要程度：全站重要页面占全站所有页面的 5% 左右，可以根据自身情况调整。</li>
<li>紧迫程度：<ul>
<li>目前的经验数据是异常率 4‰ 以上可以认为是高发率异常，但仍需继续
分析实际数据做调整。</li>
<li>（可选）异常 PV 超过 (全站访问最高页面 PV 乘以 1‰) 的也可以认为是高发量异常，
实际可以根据自身情况调整。</li>
</ul>
</li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[每周异常：第 7期，保持简单，保持拙朴]]></title>
        <link href="http://blog.hotoo.me/post/weekly-topic-about-exceptions-7"/>
        <published>2013-08-28T00:00:00.000Z</published>
        <updated>2013-08-28T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/weekly-topic-about-exceptions-7</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <h2 id="副标题：如何简单有效的发现最重要的有效异常">副标题：如何简单有效的发现最重要的有效异常</h2><blockquote>
<p>Keep It Simple, Stupid.</p>
<p>-- U.S. Navy (1960)</p>
</blockquote>
<p>在这之前，我一直苦苦寻求牛逼的算法 <a href="https://github.com/totorojs/javascript-exception-archives/issues/17">#12</a> ，
来解决这个看似简单，其实不易；仿佛不易，最终简单的问题：
找出最重要的有效异常。</p>
<p>最早的时候，我们定义了『一个异常』由以下核心部分组成：</p>
<ul>
<li>URL: 异常所在页面。</li>
<li>File: 异常代码所在文件。</li>
<li>Line: 异常代码所在行数。</li>
<li>Message: 异常消息。</li>
</ul>
<p>这些是不变的，相同页面中，同一个异常代码文件同一行，异常消息相同的异常，我们可以近似的认为它是同一个异常。</p>
<!--more-->

<p>另外还定义了异常率：</p>
<ul>
<li>异常率(PV)：『一个异常』的 PV，除以这个异常所在页面的 PV。</li>
<li>异常率(UV)：『一个异常』的 UV，除以这个异常所在页面的 UV。</li>
</ul>
<p>于是我们通过 URL, File, Line, Message 四个核心信息来统计每一个异常的 PV, UV, PV异常率，UV异常率。
并按照其中的某个字段为主进行排序。</p>
<p>但是得到的结果总是让人不尽如人意，总会有很多无法排查，甚至还有一些显然不是我们代码的问题的异常排前排。</p>
<p>我们尝试限制异常 PV, UV 的基数，尝试限制页面 PV, UV 的基数，结果仍然不理想。
而且也没有想出其他牛逼的权重算法来评估每个异常。</p>
<p>我们想过异常是跟代码所在文件和行号、异常消息有关系的，跟页面 URL 的关系不那么强，因为公共代码会在很多页面使用，把这同一个异常分散算到不同页面中会严重影响这个异常的排名。</p>
<p>但是实际上公共代码（尤其是基础类库）的异常很多情况下是业务系统调用不当，或者使用的版本有 BUG 导致，最终还是需要这个页面的开发者调整调用方法，或升级使用更新的公共脚本来解决。所以忽略或弱化异常所在页面是不可接受的。</p>
<p>而且排除了异常所在页面的信息，对于排查异常来说更为困难。</p>
<p>够了，我已经受够了，脑袋一片浆糊。
累、困，早点回家睡觉。</p>
<hr>
<p>回到家随手画了几笔，然后去洗澡。洗澡的时候想着刚刚画的思维草图，逐渐想清楚了很多。</p>
<ul>
<li>File: 由于是 seajs 自动管理依赖，以及 combo 的使用，异常所在文件本身具有不稳定性。</li>
<li>Line: 由于上面 File 的原因，不仅仅是 HTML 代码中的异常行号不稳定，静态脚本异常行号也具有不稳定性。</li>
<li>Message: 不同浏览器（包括不同版本，或者在不同操作系统中）对同一个异常有不同的消息反馈，另外还有本地化的原因，异常消息也具有不稳定性。</li>
</ul>
<p>最后，只有异常所在页面 URL（或者页面 ID，一个页面源文件可能有多个 URL 地址，但是它们是有关系的，ID 相同）才是最稳定的。</p>
<hr>
<p>于是我根据页面 URL 排列出每个页面的异常 PV, UV, PV异常率，UV异常率。并根据 PV 异常率为主进行倒序排序（每次访问都抛出的异常，比每个用户访问都抛出的异常的优先级更高）于是我们轻易得出了全站异常率最高的页面。</p>
<p>根据这个关键的页面信息，再次查询出每『一个异常』的 PV, UV, PV异常率，UV异常率。</p>
<p>以不变（页面 URL 或 ID），应万变。我们一个个把这些异常大户揪出来，各个击破。即使暂时没有发布解决，我们仍可以轻易识别排除这个已经揪出的异常。</p>
<p>好了，妈妈再也不用操心我的每周异常 TOP 数据分析了。</p>
<p>嗯， <a href="https://github.com/totorojs/javascript-exception-archives/issues/17">#12</a> 这个 issue 也可以关了。</p>
<hr>
<p>在做静态资源异常监控时，也有类似的经历。</p>
<p>静态资源监控最重要的是发现哪个页面引用了哪个 404资源，尤其是漏发的资源。因此最重要的有两个关联维度：</p>
<ul>
<li>404资源所在页面</li>
<li>404资源文件地址</li>
</ul>
<p>但是引起 404 的场景很多，包括：</p>
<ul>
<li>漏发文件。</li>
<li>静态引用地址错误。</li>
<li>动态引用地址错误。</li>
</ul>
<p>其中动态引用是由于动态脚本计算得出的静态资源地址，引发的 404 非常频繁，多样、而且分布的很散。因此这两个维度的排列组合结果就非常巨大。而且我们的分析系统是基于索引的，这些内容不确定、数量庞大的指标非常不适合用这个系统分析。（我们还有另一个非常时候实时异常分析的系统，这里不做介绍）</p>
<p>因此我们把重心放在更为稳定的页面 URL，只关注出现 404 的页面，至于是什么资源可以直接根据 URL 查询日志，或直接访问这个页面。</p>
<h2 id="小结">小结</h2><p>这篇讲的几个关键内容再强调下：</p>
<ul>
<li>保持简单，保持拙朴。</li>
<li>抓住重点，真正的核心重点。</li>
</ul>
<hr>
<p>终于可以睡了，晚安~</p>
]]>
        </content>
    </entry>
</feed>