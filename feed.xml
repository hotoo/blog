<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>闲耘™.博客</title>
    <link href="http://blog.hotoo.me/feed.xml" rel="self" />
    <link href="http://blog.hotoo.me/feed.xml" />
    <id>http://blog.hotoo.me/feed.xml</id>
    <entry>
        <title type="html"><![CDATA[gitopen, smart partner of git, hg and svn.]]></title>
        <link href="http://blog.hotoo.me/post/gitopen"/>
        <published>2015-07-24T00:00:00.000Z</published>
        <updated>2015-07-24T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/gitopen</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p>使用 Git 的你，想必会更喜欢在终端（命令行）中使用 Git。在终端中，可以将 Git
的特性发挥的淋漓尽致。</p>
<pre>$ git co -b feat-sample
$ git add .
$ git ci -m &quot;feat(sample): Add sample commit.&quot;
$ git push origin feat-sample</pre><p>咦，我想立即提交一个 Pull/Merge Request 怎么办，还要打开浏览器，输入 Git
仓库的 URL 地址，点击进入 PR 列表，再点击新建 PR，选择 feat-sample 分支，
点击确认按钮，balabala...</p>
<p>嗯，好麻烦。</p>
<p>于是 Git 的最佳伴侣 <a href="https://github.com/hotoo/gitopen">gitopen</a> 横空出世了。</p>
<p>push 了新分支，想立即提交 PR/MR，So simple.</p>
<pre>$ gitopen pr</pre><p>她会把当前分支提交一个新的 PR。</p>
<p>如果你是使用的 GitHub，在发布了新版时可能还想写个 Release Note：</p>
<pre>$ git tag 1.0.0
$ git push origin 1.0.0
$ gitopen release new 1.0.0</pre><p>咦，有个新的想法，提交个 Issue 先：</p>
<pre>$ gitopen issue</pre><p>再来个 milestone 尝尝：</p>
<pre>$ gitopen milestone</pre><p>这货支持</p>
<ul>
<li>git, hg, svn.</li>
<li>Mac OS X, Linux, Windows.</li>
<li>GitHub (Enterprise), GitLab (CE, EE), BitBucket (Atlassian), GitCafe (Enterprise) ...</li>
</ul>
<p>更多功能参考：</p>
<pre>$ npm install gitopen -g
$ gitopen @hotoo/gitopen</pre>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[git+, a hack of git, smart for you.]]></title>
        <link href="http://blog.hotoo.me/post/gitplus"/>
        <published>2015-05-27T00:00:00.000Z</published>
        <updated>2015-05-27T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/gitplus</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p>为了信息安全，公司搭建了 gitlab.company.com 管理代码，同时限制了必须使用工作邮箱
hotoo@company.com 进行提交。</p>
<p>公司 gitlab 有大大小小很多仓库，不时的需要 clone 代码下来，有时忘记设置就开始提交，
提交了几次开始 push 到 gitlab 并准备提交 MR 时发现，push 被拒绝，或者 MR 无法
自动合并，因为没有使用公司的邮箱进行提交。只好取消之前的提交操作，修改邮箱配置
之后重新提交。</p>
<p>虽然 clone 下来配置一次就可以了，但是每个仓库都需要配置，每次 clone 都需要配置，
忘记设置了需要取消之前的提交并再来一次。</p>
<p>有没有办法自动进行配置呢？</p>
<p>于是 <a href="https://github.com/hotoo/gitplus">gitplus</a> 出现了，它可以根据 git
的子操作命令，及其所在的仓库信息，自动的执行指定命令，帮助你完成一些自动化任务。
例如：</p>
<pre>post-clone:
  gitlab.company.com:
    - git config user.name hotoo
    - git config user.email hotoo@company.com
pre-commit:
  &#39;*&#39;:
    - jshint .</pre><ul>
<li>有了 gitplus，你再也不会忘记设置公司邮箱。因此也不需要取消提交再重复提交了。</li>
<li>还可以在提交前自动做校验工作。没有 gitplus 之前你只能给每个仓库设置 pre-commit hooks。</li>
<li>你也可以发挥自己的想象力，做更多其他的事情。</li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[译：严重混乱的 Resource Timing]]></title>
        <link href="http://blog.hotoo.me/post/serious-confusion-with-resource-timing"/>
        <published>2014-12-30T00:00:00.000Z</published>
        <updated>2014-12-30T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/serious-confusion-with-resource-timing</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <h1 id="或者说『耗时包含了-blocking-部分的时间』">或者说『耗时包含了 Blocking 部分的时间』</h1><p>用 <a href="http://www.w3.org/TR/resource-timing/">Resource Timing</a> 来同统计资源下载性能
是非常赞的方式，但不幸的是，几乎所有和我聊过的人都是使用 <a href="http://www.w3.org/TR/resource-timing/#duration-attribute"><code>duration</code> 属性</a>，
而且他们都没有意识到 <code>duration</code> 包含了 blocking 时间。结果 <code>duration</code> 时间
比实际的下载时间要长很多，超出了开发者意料之外的结果。这个问题在跨域资源中
尤为糟糕，<code>duration</code> 是唯一可用的。在这篇博文中我将解释这个问题，并提出解决方案。</p>
<h2 id="resource-timing-回顾">Resource Timing 回顾</h2><p><a href="http://www.w3.org/TR/resource-timing/">Resource Timing 规范</a> 定义了收集网页中
所有资源耗时统计的 API。现在可用于 Chrome, Chrome for Android, IE 10-11, 和 Opera。
可以通过 <code>getEntries()</code>, <code>getEntriesByType()</code> 和 <code>getEntriesByName()</code> 得到一个
<code>PerformanceEntry</code> 列表，一个 <code>PerformanceEntry</code> 对象包含以下属性：</p>
<ul>
<li><code>name</code> – URL 地址</li>
<li><code>entryType</code> – 通常是 “resource”</li>
<li><code>startTime</code> – 开始处理这个资源的时间（相对开始导航到页面时的毫秒数）</li>
<li><code>duration</code> – 处理这个资源的总耗时（毫秒）</li>
</ul>
<p>上面的属性在所有的资源中都可用，包括同域和跨域的。而同域的资源拥有另外一些可以
访问的附加属性，这些属性定义在 <code>PerformanceResourceTiming</code> 接口中。这些属性名称
很简洁清晰，完全可以见名思意，并且以时间顺序排序：</p>
<ul>
<li>redirectStart</li>
<li>redirectEnd</li>
<li>fetchStart</li>
<li>domainLookupStart</li>
<li>domainLookupEnd</li>
<li>connectStart</li>
<li>connectEnd</li>
<li>secureConnectionStart</li>
<li>requestStart</li>
<li>responseStart</li>
<li>responseEnd</li>
</ul>
<p>这里有个权威的 <a href="http://www.w3.org/TR/resource-timing/#processing-model">处理模型(processing model)</a> 图
显示了这些属性所在的各个不同阶段。备注：<code>duration</code> 相当于 <code>responseEnd - startTime</code>。</p>
<p><img src="http://www.w3.org/TR/resource-timing/resource-timing-overview.png" alt="processing model graphic"></p>
<p>如何使用 Resource Timing 的详细信息，可以参考我的文章 <a href="http://www.stevesouders.com/blog/2014/08/21/resource-timing-practical-tips/">Resource Timing Practical Tips</a> 『<a href="./resource-timing-practical-tips">译者的中文翻译</a>』</p>
<h2 id="duration-中出乎意外的-blocking-膨胀"><code>duration</code> 中出乎意外的 blocking 膨胀</h2><p>出于隐私的考虑，同源资源的 PerformanceResourceTiming 属性是受限的。（备注：
任何资源可以通过 <code>Timing-Allow-Origin</code> 响应头达到“同源”效果。）现在大约有一半
的资源是跨域的，因此 <code>duration</code> 是度量加载时间的唯一方式。而且即使是同源资源，
<code>duration</code> 也是唯一以增量方式提供的属性，大概是因为它度量了最重要的阶段。
这样一来，所有我见过的 Resource Timing 实现都以 <code>duration</code> 做为主要的性能指标。</p>
<p>不幸的是，<code>duration</code> 比下载时间要大，它包含了阻塞时间（blocking time）—— 浏览器
意识到需要下载一个资源，到这个资源实际被下载直接的时间延迟。阻塞会在几种情况时
发生，最典型的资源数量比 TCP 连接数要多的情况。大多数浏览器为每个主机开放了 6
个 TCP 连接，IE10（8个连接）和 IE11（12个连接）例外。</p>
<p>这个 <a href="http://stevesouders.com/tests/rt-blocking.php">Resource Timing 阻塞测试页面</a>
有 16 个图片，因此无论哪个浏览器都会阻塞一部分图片。每个图片被编程为在服务器
有 1 秒的延迟，这 16 个图片，每个图片都显示了 <code>startTime</code> 和 <code>duration</code>。
另外还有这个测试页面在 WebPagetest 中通过 <a href="http://www.webpagetest.org/result/141125_4T_11FT/">Chrome</a>,
<a href="http://www.webpagetest.org/result/141125_BN_11FY/">IE10</a> 和
<a href="http://www.webpagetest.org/result/141125_5K_11CB/">IE11</a> 加载的测试结果，
可以通过查看截屏来分析时序结果。注，为什么所有的图片的 <code>startTime</code> 大致都相同？
英文这个时间是浏览器解析 IMG 标签并意识到需要下载改资源的时间，由于先下载的图片
阻塞的原因，但在页面出现后，图片的 <code>duration</code> 值大约步进 1 秒左右。</p>
<h2 id="译者补充">译者补充</h2><ul>
<li><a href="http://www.stevesouders.com/blog/2014/11/25/serious-confusion-with-resource-timing/">SERIOUS CONFUSION with Resource Timing</a> - 原文出处。</li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[译：Resource Timing (资源计时) 使用技巧]]></title>
        <link href="http://blog.hotoo.me/post/resource-timing-practical-tips"/>
        <published>2014-12-30T00:00:00.000Z</published>
        <updated>2014-12-30T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/resource-timing-practical-tips</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p><a href="http://www.w3.org/2010/webperf/">W3C Web 性能工作组</a> 在 2012 年给我们带来了
<a href="http://www.w3.org/TR/navigation-timing/">Navigation Timing</a>，这个 API 现在
基本上在主流浏览器上都可用。Navigation Timing 定义了一套用于测量主页面性能的
JavaScript API。例如：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Navigation Timing</span>
<span class="keyword">var</span> t = performance.timing,
    pageloadtime = t.loadEventStart - t.navigationStart,
    dns = t.domainLookupEnd - t.domainLookupStart,
    tcp = t.connectEnd - t.connectStart,
    ttfb = t.responseStart - t.navigationStart;</code></pre></div><!--more-->

<p>能够度量主页面的时间消耗真是太棒了，但是要诊断现实当中的性能问题，往往需要深入
到各个资源当中。所以我们拥有了更进一步的 Resource Timing （资源计时）规范，
这个 JavaScript API 提供类似 Navigation Timing 的功能，但是能精确到每一个资源的
耗时。举个例子：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Resource Timing</span>
<span class="keyword">var</span> r0 = performance.getEntriesByType(<span class="string">"resource"</span>)[<span class="number">0</span>],
    loadtime = r0.duration,
    dns = r0.domainLookupEnd - r0.domainLookupStart,
    tcp = r0.connectEnd - r0.connectStart,
    ttfb = r0.responseStart - r0.startTime;</code></pre></div><p>到目前为止，Chrome, Chrome for Android, Opera, IE10 和 IE11
浏览器都支持 Resource Timing，这也许超过了你的网站 50% 的流量。
这应该可以提供足够的数据，来揭示这些资源缓慢的原因。</p>
<p>使用 Resource Timing 看似很简单，但是当我在写第一个用于生产环境的 Resource Timing 代码
时，遇到了许多问题。这里我想分享一些现实当中记录 Resource Timing 指标的实用技巧。</p>
<h2 id="1-使用-getentriesbytype-quot-resource-quot-而不是-getentries">1. 使用 <code>getEntriesByType(&quot;resource&quot;)</code> 而不是 <code>getEntries()</code></h2><p>在使用 Resource Timing 来获取当前页面的资源集合的资源耗时性能对象时，许多 Resource
Timing 示例都是使用 <code>performance.getEntries()</code>，这意味着唯一的 resource timing 对象
由该调用进行返回。但是 <code>getEntries()</code> 会一并返回潜在的 <a href="http://www.w3.org/wiki/Web_Performance/EntryType">4 种类型的 timing 对象</a>：
<code>resource</code>（资源），<code>navigation</code> （导航）, <code>mark</code> （标记）, 和 <code>measure</code> （测量）。</p>
<p>这并没有造成多大问题，因为目前 <code>resource</code> 是大多数网页的唯一类型。
<code>navigation</code> 类型是 <a href="http://www.w3.org/TR/navigation-timing-2/">Navigation Timing 2</a> 的一部分，据我所知目前没有被任何浏览器所实现。
<code>mark</code> 和 <code>measure</code> 类型是从 <a href="http://www.w3.org/TR/user-timing/">User Timing</a> 规范衍生出来的，在部分浏览器中可用，
但是还没有被广泛使用。</p>
<p>也就是说，<code>getEntriesByType(&quot;resource&quot;)</code> 以及 <code>getEntries()</code> 在今天可能返回相同
的结果，但是可能 <code>getEntries()</code> 将很快返回多种性能对象的混合集合，所以最好是
使用 <code>performance.getEntriesByType(&quot;resource&quot;)</code>，你可以明确的只获取 resource
timing 对象。（感谢 <a href="http://calendar.perfplanet.com/2012/an-introduction-to-the-resource-timing-api/">Andy Davies</a> 给我解释这一点）</p>
<h2 id="2-使用-navigation-timing-测量主页面的请求。">2. 使用 Navigation Timing 测量主页面的请求。</h2><p>当通过典型的请求获取一个网页的主 HTML 文档，但是这个资源并不能通过
<code>performance.getEntriesByType(&quot;resource&quot;)</code> 得到返回，要得到这个主页面 HTML 文档
的 timing 信息，需要使用 Navigation Timing 对象（<code>performance.timing</code>）。</p>
<p>虽然不太可能，当页面上没有其他资源时，这可能会导致错误发生。
例如，刚才 Resource Timing 示例使用如下代码：</p>
<div class="highlight"><pre><code class="javascript">performance.getEntriesByType(<span class="string">"resource"</span>)[<span class="number">0</span>]</code></pre></div><p>如果一个页面唯一的资源就是主页面的 HTML 文档，然后 <code>getEntriesByType(&quot;resource&quot;)</code>
返回一个空数组，这时候应用 <code>element[0]</code> 会引起 JavaScript 异常。如果你找不到
没有引用子资源的页面，你可以试试 <a href="http://fast.stevesouders.com/">http://fast.stevesouders.com/</a></p>
<h2 id="3-小心-secureconnectionstart-的问题。">3. 小心 <code>secureConnectionStart</code> 的问题。</h2><p><a href="http://www.w3.org/TR/resource-timing/#dom-performanceresourcetiming-secureconnectionstart"><code>secureConnectionStart</code></a>
属性我们衡量 SSL 协商需要多长时间。这非常重要，我经常
看到 500 毫秒以上的 SSL 协商时间，甚至更多。<code>secureConnectionStart</code> 有 3 种
可能的值：</p>
<ul>
<li>如果该属性不可用，则必须设置为 <code>undefined</code>。</li>
<li>如果不使用 HTTPS 的，则必须设置为 0.</li>
<li>如果该属性可用，并且使用了 HTTPS，则必须设置为一个时间戳。</li>
</ul>
<p>关于 <code>secureConnectionStart</code>，有三件事情需要了解下：</p>
<p>首先，在 Internet Explorer 中，<code>secureConnectionStart</code> 的值总是 <code>undefined</code>，
因为它是不可用的（该值被埋在 <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa383630(v=vs.85\">WinINet</a>.aspx) 之下）。</p>
<p>其次，在 Chrome 中有个 BUG 会导致 <code>secureConnectionStart</code> 被错误的设置为 0 的问题。
如果获取一个资源时使用预先存在的 HTTPS 连接，则 <code>secureConnectionStart</code> 将被设置
为 0，而实际上它应该是一个时间戳。（详情请参考 <a href="https://code.google.com/p/chromium/issues/detail?id=404501">bug 404501</a> ）
为了避免这个问题，测量 SSL 协商时间时，一定要检查 <code>secureConnectionStart</code> 既不是
<code>undefined</code> 也不是 <code>0</code>：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> r0 = performance.getEntriesByType(<span class="string">"resource"</span>)[<span class="number">0</span>];
<span class="keyword">if</span> ( r0.secureConnectionStart ) {
    <span class="keyword">var</span> ssl = r0.connectEnd - r0.secureConnectionStart;
}</code></pre></div><p>第三，规范中关于 <a href="http://www.w3.org/TR/resource-timing/#dom-performanceresourcetiming-secureconnectionstart">这一行</a>
有一些误导：“...如果当前页面的协议是 HTTPS，这个属性必须立即返回用户代理(user agent)开始握手过程的时间...”
（我的重点）。有可能当前页面是 HTTP，但仍然包含我们需要测量 SSL 协商时间的 HTTPS 资源。
规范应该改为：“...如果资源的协议是 HTTPS 协议，该属性必须立即返回用户代理开始握手过程的时间...”。
幸运的是，浏览器是使用纠正后的行为，而已就是说， <code>secureConnectionStart</code> 可用于
HTTP 页面中的 HTTPS 资源。</p>
<h2 id="4-给跨域资源添加-timing-allow-origin-http-响应头">4. 给跨域资源添加 <code>Timing-Allow-Origin</code> HTTP 响应头</h2><p>出于隐私保护的原因，在获得资源的 Resource Timing 详情时有<a href="http://www.w3.org/TR/resource-timing/#cross-origin-resources">跨域限制</a>。
默认情况下，与主页面不同域的资源，下列属性被设置为 0：</p>
<ul>
<li>redirectStart</li>
<li>redirectEnd</li>
<li>domainLookupStart</li>
<li>domainLookupEnd</li>
<li>connectStart</li>
<li>connectEnd</li>
<li>secureConnectionStart</li>
<li>requestStart</li>
<li>responseStart</li>
</ul>
<p>在某些情况下，仍然希望测量跨域资源的性能，例如，当网站使用不用域名的 CDN（例如
&quot;youtube.com&quot; 使用 &quot;s.ytimg.com&quot;），以及某些第三方资源（例如 &quot;ajax.googleapis.com&quot;）。
如果资源返回 <a href="http://www.w3.org/TR/resource-timing/#timing-allow-origin">Timing-Allow-Origin</a>
响应头，跨域资源的 timing 详情将被授权访问。这个头信息指定了被允许访问 timing
详情的（主页面）来源列表，多数情况下，会使用通配符(<code>*</code>) 允许所有来源访问。
举个例子，<a href="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js">http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js</a> 返回
的 Timing-Allow-Origin 响应头信息是：</p>
<pre>Timing-Allow-Origin: *</pre><p>当第三方添加这个响应头信息时，真是太棒了。它允许站长来统计在他们网页上使用的
第三方资源的性能。感谢 <a href="http://googledevelopers.blogspot.com/2013/12/measuring-network-performance-with.html">Ilya Grigorik</a>
报告了一些添加了这个响应头的第三方资讯，下面是一些指定了 <code>Timing-Allow-Origin: *</code>
的资源例子：</p>
<ul>
<li>Google Hosted Libraries: <a href="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js">http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js</a></li>
<li>Google+ widgets: <a href="https://apis.google.com/js/plusone.js">https://apis.google.com/js/plusone.js</a></li>
<li>Google Fonts:  <a href="http://fonts.gstatic.com/s/opensans/v9/DXI[snip...]N3Vs.woff2">http://fonts.gstatic.com/s/opensans/v9/DXI[snip...]N3Vs.woff2</a></li>
<li>Facebook widgets: <a href="http://connect.facebook.net/en_US/all.js">http://connect.facebook.net/en_US/all.js</a></li>
<li>Disqus widgets: <a href="http://go.disqus.com/embed.js">http://go.disqus.com/embed.js</a></li>
</ul>
<p>当需要访问有限制的 timing 属性时，决定统计 Resource Timing 是非常重要的。
可以通过检测（上面列出的，secureConnectionStart 除外）限制性属性是否为 0 的方式
来避免限制性问题，我总是使用 <code>requestStart</code>。下面是用于在计算详细的性能指标之前，
检测和计算限制性属性是否可用的代码片段：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Resource Timing</span>
<span class="keyword">var</span> r0 = performance.getEntriesByType(<span class="string">"resource"</span>)[<span class="number">0</span>],
    loadtime = r0.duration;
<span class="keyword">if</span> ( r0.requestStart ) {
    <span class="keyword">var</span> dns = r0.domainLookupEnd - r0.domainLookupStart,
        tcp = r0.connectEnd - r0.connectStart,
        ttfb = r0.responseStart - r0.startTime;
}
<span class="keyword">if</span> ( r0.secureConnectionStart ) {
    <span class="keyword">var</span> ssl = r0.connectEnd - r0.secureConnectionStart;
}</code></pre></div><p>做这些检测是非常重要的，否则，当访问这些受限属性时，你不会得到任何异常，除了
这些虚假的数据。当属性受限访问时，它们的值被设置为 0，例如 <code>domainLookupEnd - domainLookupStart</code>
翻译成 <code>0 - 0</code>，它返回一个似是而非的结果 <code>0</code>，而这可能并不是真实 DNS 查询时间。
这将导致过多的指标为 <code>0</code> 而让你过于乐观。</p>
<h2 id="5-理解-0-意味着什么。">5. 理解 0 意味着什么。</h2><p>在第 4 节当中提到，一些因为跨域导致的受限访问的 Resource Timing 属性会被设置为
0。再强调一次，在访问属性详情之前，要检查属性状态是非常重要的。
但是即使受限属性都是可访问的，度量计算的返回结果也有可能是 0，所以理解这意味着
什么非常重要。</p>
<p>例如，（假设没有访问限制）<code>domainLookupStart</code> 和 <code>domainLookupEnd</code> 的值是两个
时间戳，这两个值之差是该资源在 DNS 解析上耗时。通常情况下，一个页面中指定的域名
只有一个非 0 的 DNS 解析耗时，因为浏览器会缓存 DNS 解析，所有后续的请求都使用
这个缓存的 DNS 解析。而且由于跨页面的 DNS 解析缓存，一个页面所有的 DNS 解析
计算结果可能都是 0。关键点：DNS 解析耗时为 0 意味着资源是从缓存中读取的。</p>
<p>同样，对于指定的主机名，如果重复利用已存在的 TCP 连接，那么建立 TCP 连接（<code>connectEnd - connectStart</code>）
的耗时也会是 0。每个主机有大约 6 个独立的 TCP 连接，这表明应该有 6 个非 0 的
TCP 连接测量值，但是这个主机后续的请求将使用已存在的 TCP 连接，并且他们的
TCP 连接耗时为 0。关键点：TCP 连接耗时为 0 意味着重复使用了已存在的 TCP 连接。</p>
<p>这同样适用于计算 SSL 协商（<code>connectEnd - secureConnectionStart</code>）。这个可能
有 6 个以上的资源，但是同一主机名的所有的后续请求可能都使用同一个已存在的 HTTPS
连接，以至于它的 SSL 协商时间为 0。</p>
<p>最后，如果属性持续的为 0，这可能意味资源是从缓存中读取的。</p>
<h2 id="6-确定-304-是否被测量。">6. 确定 304 是否被测量。</h2><p>这是另一个 Chrome 稳定版（版本号 36）的 BUG，这个 BUG 在 37 版时被修复。
这个问题已经被修复了，但是由于大多数用户还是使用 Chrome 稳定版，你当前的性能
指标可能跟实际上的并不相同。这个 BUG 是：一个拥有 Timing-Allow-Origin 的跨域
页面，200 响应状态并不会考虑 304 响应状态，因此，304 响应下所有的受限属性都
将显示为 0，例如 <a href="http://stevesouders.com/tests/tao.php">这个测试页面</a>。</p>
<p>这是不应该发生的，因为从 200 响应的缓存中读取的 Timing-Allow-Origin 头信息
应该应用到 304 响应中。在 Internet Explorer 浏览器中就是这样。（可以在 IE 10
或者 11 中尝试 <a href="http://stevesouders.com/tests/tao.php">这个页面</a> 来确认。）
（感谢 <a href="https://twitter.com/ericlaw">Eric Lawrence</a> 指出这一点。）</p>
<p>这会影响你的 Chrome Resource Timing 结果如下：</p>
<ul>
<li>如果（如第 4 节所述）使用检查 0 值的方式来判断受限字段，则会跳过测量 304 响应，
也就是说值测量了 200 状态响应，但是由于 200 状态响应比 304 要慢，所以 Resource
Timing 测量总量会比实际的要大。</li>
<li>反之如果不检查受限字段为 0 的情况，会得到许多的 0 值记录，
这实际上又比 304 响应要快，这样 Resource Timing 统计结果又会过于乐观。</li>
</ul>
<p>没有简单的方式来避免这些偏见，但是好消息是这个 BUG 被修复了。另外还可以尝试做的
事情是，304 响应头中发送 Timing-Allow-Origin 头，不幸的是，流行的 Apache Web
服务器不支持在 304 响应头中发送这个头信息（查看 <a href="https://issues.apache.org/bugzilla/show_bug.cgi?id=51223">BUG 51223</a>）。
缺乏进一步证件证明第 4 节提到那些第三方资源的 304 响应头中的 Timing-Allow-Origin
可以被找到。如前所述，这些第三方资源在 200 响应头中返回 Timing-Allow-Origin 头，
但是 304 响应头中不返回 Timing-Allow-Origin 头，这真是太好了。
到 Chrome 37 成为稳定版之前，因为缺少了受限属性的细节，Resource Timing 测量结果
可能偏高或偏低。幸运的是，时间会改变一切。</p>
<h2 id="7-看看-boomerang（回旋镖）">7. 看看 Boomerang（回旋镖）.</h2><p>如果你准备写自己 Resource Timing 代码，建议你最好看看 <a href="http://www.lognormal.com/boomerang/doc/api/restiming.html">Resource Timing 插件 Boomerang</a>。
（代码在 <a href="https://github.com/lognormal/boomerang/blob/master/plugins/restiming.js">GitHub</a> 上。）
Boomerang 是 Philip Tellis 维护的一个非常流行的开源 RUM 包。他起初在 Yahoo 工作
的时候就开源了 Boomerang，而现在作为在 SOASTA 工作的商业版的一部分（mPulse），
他仍然在持续的提供维护和增强。t它的代码很清晰、简洁和健壮，并解决了上面提到的许多问题。</p>
<p>总之，Navigation Timing 和 Resource Timing 都是非常优秀的新规范，为站长了解他们
的页面性能提供了很好的支持。Resource Timing 是这两个规范中更新的一个规范，因此
还是会有一些问题待解决。这些小提示将帮助你充分的利用 Resource Timing 指标。
我建议你现在就开始监控这些指标，以理解你的网站性能，为了最关心这个问题的真实用户。</p>
<blockquote>
<p>更新：有一些第三方资源提供了 Timing-Allow-Origin 响应头，以允许站长测量这些
第三方资源的性能：</p>
<ul>
<li>Boomerang: <a href="http://c.go-mpulse.net/boomerang/CEN[snip...]YQE">http://c.go-mpulse.net/boomerang/CEN[snip...]YQE</a></li>
<li>Typekit: <a href="https://use.typekit.net/previewkits/pk-v1.js">https://use.typekit.net/previewkits/pk-v1.js</a></li>
</ul>
</blockquote>
<p/>

<blockquote>
<p>更新：<code>getEntriesByType(&quot;resource&quot;)</code> 和 <code>getEntries()</code> 不包含 iframe 页面的性能，
如果 iframe 是同源的，可以在父页面通过 <code>contentWindow.performance</code> 对象访问
这些指标。</p>
</blockquote>
<h2 id="译者补充">译者补充</h2><ul>
<li><a href="http://www.stevesouders.com/blog/2014/08/21/resource-timing-practical-tips/">Resource Timing practical tips</a> - 原文出处。</li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[GitHub, GitLab, or BitBucket?]]></title>
        <link href="http://blog.hotoo.me/post/github-gitlab-or-bitbucket"/>
        <published>2014-08-03T00:00:00.000Z</published>
        <updated>2014-08-03T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/github-gitlab-or-bitbucket</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <blockquote>
<p>GitHub 是汇集了众多开源项目的闭源系统，</p>
<p>GitLab 是汇聚了较多闭源项目的开源系统。</p>
<p>-- <a href="https://twitter.com/hotoo/status/417483811212238848">@hotoo</a></p>
</blockquote>
<p>对于个人开发者，不可避免的会有私有项目的需求。</p>
<p>目前比较靠谱的私有项目托管服务有：</p>
<ul>
<li>GitHub</li>
<li>GitLab</li>
<li>BitBucket</li>
</ul>
<p>下面我们稍做评比。</p>
<!--more-->

<h2 id="github">GitHub</h2><p>GitHub 当下大红大紫，主要在于其社交性质。</p>
<p>对于开源项目来说，上面大量的开发者参与带来了非常活跃的开发氛围。</p>
<p>但是对于私有仓库来说，个人觉得价格偏贵（屌丝气质暴露）。</p>
<p>而且个人账户下的私有仓库，不能共享给个人所拥有的团队账户，因此如果团队账户需要
私有仓库，则需要另外再为团队账户购买。</p>
<p>如果不缺钱，可以考虑 GitHub，甚至还有 Enterprise 版本。</p>
<h2 id="gitlab">GitLab</h2><p>GitLab 是当下最火的 Git 仓库管理的开源项目，有提供的 <a href="https://gitlab.com/">gitlab.com</a>
服务，同时可以自行部署。</p>
<p>gitlab.com 服务可以创建不限数量的私有仓库，除了少量的缺点外，GitLab 几乎可以
媲美 GitHub。</p>
<p>但是，作为完美主义者，真的受不了 GitLab 的一些小伤疤。</p>
<h2 id="bitbucket">BitBucket</h2><p>BitBucket 是 <a href="https://www.atlassian.com/">Atlassian</a> 公司的产品
（还有 Confluence，JIRA， HipChat 等著名产品）。</p>
<p>个人觉得除了 Issues 不够简洁之外，其他都很完美。
适合小团队私有项目托管。</p>
<h2 id="对比">对比</h2><table>
<thead>
<tr>
<th></th>
<th>GitHub</th>
<th>GitLab</th>
<th>BitBucket</th>
</tr>
</thead>
<tbody>
<tr>
<td>私有仓库</td>
<td>收费<br/>教育身份赞助 2年的 Micro Plan</td>
<td>免费，无限制</td>
<td>免费，限制协作人数</td>
</tr>
<tr>
<td>权限控制</td>
<td>个人账户无控制<br/>团队账户有限控制</td>
<td>仓库级控制<br/>指定一个保护分支</td>
<td>分支级控制</td>
</tr>
<tr>
<td>Transfer</td>
<td>完美</td>
<td>几乎完美</td>
<td>完美</td>
</tr>
<tr>
<td>仓库重命名</td>
<td>完美</td>
<td>不能修改 clone 地址</td>
<td>完美</td>
</tr>
<tr>
<td>仓库名</td>
<td>完美</td>
<td>不能使用 <code>.</code>，自动修改为 <code>-</code></td>
<td>完美</td>
</tr>
<tr>
<td>Issues</td>
<td>完美</td>
<td>功能复杂，但界面简洁<br/>早期有 Issues ID 缺陷，已修复</td>
<td>功能复杂，界面不够简洁</td>
</tr>
<tr>
<td>Issues URL</td>
<td>完美</td>
<td>完美</td>
<td>默认附加可选的标题信息</td>
</tr>
<tr>
<td>Pages</td>
<td>username.github.io 仓库<br/>gh-page 分支</td>
<td>demo 分支</td>
<td>username.bitbucket.org 仓库</td>
</tr>
<tr>
<td>自定义域名</td>
<td>每个仓库都可以自定义域名</td>
<td>无</td>
<td>个人 Profile 页</td>
</tr>
</tbody>
</table>
<h2 id="小结">小结</h2><ul>
<li>GitHub 适合开源项目管理。不缺钱的同学，私有项目也适合统一在 GitHub 管理。</li>
<li>GitLab 和 BitBucket 都很适合私有项目的管理。</li>
<li>GitLab 是开源项目，活跃程度很高，未来很有潜力，如果不在乎那些小硬伤，个人更推荐 GitLab。</li>
<li>BitBucket 系出名门，产品本身也非常好，没有明显的伤疤，作为完美主义者，我目前稍喜欢这个。</li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[定位到服务器集群的特定节点]]></title>
        <link href="http://blog.hotoo.me/post/find-nodes-from-server-cluster"/>
        <published>2014-04-17T00:00:00.000Z</published>
        <updated>2014-04-17T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/find-nodes-from-server-cluster</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <blockquote>
<p>齐宣王使人吹竽，必三百人。南郭处士请为王吹竽，宣王说之，廪食以数百人。
宣王死，湣王立，好一一听之，处士逃。</p>
<p>《韩非子·内储说上》</p>
</blockquote>
<h2 id="背景">背景</h2><p>某日，突然收到报警，某发现实时异常监控趋势图上，静态资源 404 异常有明显的上升。
分析详细的异常信息发现是某个发布操作引起某几个系统引起的。</p>
<!--more-->

<hr>
<p>找到对应的开发，分析结论是部分配置文件未生效，导致拼接资源文件地址错误。
按照业务量计算，这个异常量大约是其中一、两台机器有问题。</p>
<p>可能发布系统或其他问题，重新发布一次仍没能修复这个异常。</p>
<p>我们需要快速定位到这只滥竽，尽快将问题修复。
但是实际上却没有这么简单，我们最终花费 了 7个多小时，最终是因为这个系统正好有
其他发布才顺便解决。</p>
<p><img src="https://i.alipayobjects.com/i/localhost/png/201404/2TD6uw5N0n.png" alt="realtile-error-trend"></p>
<p>上图有两个造成异常的发布，分别是『CMS 发布』和『后台系统发布』。</p>
<p>橙色是 JavaScript 实时异常，绿色是静态资源 404 异常。</p>
<h2 id="方案">方案</h2><p>事后我们坐下来讨论如何解决这个问题，避免在以后遇到类似问题时能快速有效的应对。</p>
<p><img src="https://i.alipayobjects.com/i/localhost/png/201404/2Tdj3TmMdR.png" alt="异常过程序列图"></p>
<p>如上图，问题出在某个问题业务应用服务器节点配置文件未生效，拼接出来的 JavaScript
资源地址不正确导致 CDN 节点未命中而最终回源，源服务器也没有这个文件，最终发生
404 悲剧。</p>
<p>实际的业务系统中，会提供用户访问的节点信息，但是请求静态资源时无法获得这个信息，
是不是有办法在静态资源源服务器上获得来源页面所在的服务器节点信息呢？</p>
<ol>
<li>方案一：我们首先想到 Cookie。但是应用服务器和静态资源服务器分别在不同的域名
下，即使在访问应用服务器时写入节点信息到 Cookie 中，这个信息也不会携带到静态
资源服务器。『失败』。</li>
<li>方案二：CDN 节点域提供外部写 Cookie 的接口，用户访问应用服务时，同时调用接口
在 CDN 节点所在域写入用户访问应用服务器节点信息。『放弃』，缺点：<ol>
<li>成本高。</li>
<li>风险大。</li>
</ol>
</li>
<li>方案三：然后想到每个应用系统重写静态资源地址，在地址中携带当前应用服务器节点
信息。『放弃』，缺点：<ol>
<li>成本过高。</li>
<li>导致 CDN 命中率下降。</li>
</ol>
</li>
<li><p>方案四：重写用户访问页面地址，附带应用服务器节点信息。成本过高，『放弃』。</p>
<p>从前端角度直接解决这个看似无望，换个思路。</p>
</li>
<li><p>方案五：在网络内部，使用内部代理。如 <code>curl -I -x internal-host:port url</code>
『可行』，缺点：</p>
<ol>
<li>需要在服务器所在内网执行，指定目标服务器内部 IP，因此只有系统管理员可以操作。</li>
<li>而系统管理员不清楚实际应用业务。</li>
</ol>
</li>
<li><p>方案六：如果可以在外部指定服务器节点访问应用，是不是可行呢？</p>
<p>这个跟负载均衡规则有关，如果负载均衡服务器支持这个特性，或可一试。</p>
<p>跟相关同学沟通后，表示可以做。而且从外网直接访问，清楚业务的开发同学可以自行
排查。</p>
<p>『可行』。需要注意的问题：</p>
<ol>
<li>逐个击破，定向攻击。<ol>
<li>可以通过拒绝频繁的指定节点访问请求来防范。</li>
<li>可以通过白名单内部 IP 才可以使用。</li>
</ol>
</li>
</ol>
</li>
<li>方案七：客户端脚本扫描所有外部资源，并发起请求来确认各个资源状态。『放弃』，
缺点：<ul>
<li>增加静态资源服务器压力。</li>
<li>增加网络请求和流量。</li>
</ul>
</li>
<li>方案八：客户端脚本监听静态资源异常事件。HTML5 现在提供了 Performance Timing
API，可以用来监控网页及其引用的外部资源加载时间，将来提供类似的 API 可以监听
静态资源的 error 事件也未可知。『期待』</li>
<li>方案九：Web 服务器端输出时拦截器扫描。尤其目前前端往后端延伸，能做的事情更多
了。『可行』。</li>
</ol>
<h2 id="结论">结论</h2><p>综上所述，在成本、风险、自动化、扩展性等方面来讲，方案九是最优的。</p>
<h2 id="延伸思考">延伸思考</h2><p>图二所示，这次问题出在业务应用服务器集群的节点 1。</p>
<ul>
<li>如果问题节点是静态资源 CDN 集群的节点 2 呢？</li>
<li>问题节点是节点 3？</li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[转换 Vimwiki 为 Markdown]]></title>
        <link href="http://blog.hotoo.me/post/convert-vimwiki-to-markdown"/>
        <published>2014-03-31T00:00:00.000Z</published>
        <updated>2014-03-31T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/convert-vimwiki-to-markdown</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <blockquote>
<p><code>sed -f ex -i *.md</code></p>
</blockquote>
<h2 id="readme">README</h2><p>相对 Wiki 语法，和 Wiki 对应工具支持情况，我更加喜欢 Markdown 了。
本地配合使用 Vimwiki 来编辑查看，发布使用 nico 来转换，而且有 Github 的原生支持，
使用 Markdown 是不二之选。</p>
<p>为了减少转换工作量，我简要写了这个脚本，可以初步将 vimwiki 语法的项目，
自动转换成 markdown 语法。</p>
<!--more-->

<p>转换的内容包括：</p>
<ul>
<li>header</li>
<li>codes</li>
<li>wikiword.</li>
<li>links</li>
<li>images</li>
<li>comments</li>
<li>%toc</li>
<li>%title</li>
<li>%nohtml</li>
</ul>
<h2 id="usage">Usage</h2><p>假设上面的脚本保存结构如下：</p>
<pre>/
|- convert.sh
|- ex
|- vimwiki/
  |- index.wiki
  `- vim.wiki</pre><p>在 convert.sh 同级目录执行：</p>
<pre>$ ./convert.sh vimwiki/*.wiki</pre><p>然后自动或手动调整之后，删除 <code>.wiki</code> 文件即可。</p>
<h2 id="codes">Codes</h2><h3 id="convert-sh">convert.sh</h3><div class="highlight"><pre><code class="bash"><span class="shebang">#!/usr/bin/env bash
</span>
<span class="keyword">for</span> x
<span class="keyword">do</span>
  filename=$(<span class="built_in">echo</span> <span class="variable">$x</span>|sed <span class="operator">-e</span> <span class="string">"s/\.wiki$/.md/"</span>)
  sed <span class="operator">-f</span> ex <span class="variable">$x</span> &gt; <span class="variable">$filename</span>
<span class="keyword">done</span></code></pre></div><h3 id="ex">ex</h3><pre>s/# \(.*\)$/* \1/g
s/^= \(.*\) =$/# \1/g
s/^== \(.*\) ==$/## \1/g
s/^=== \(.*\) ===$/### \1/g
s/^==== \(.*\) ====$/#### \1/g
s/^===== \(.*\) =====$/##### \1/g
s/^====== \(.*\) ======$/###### \1/g
s/{{{class=&quot;brush: *\([^&quot;]*\)&quot;/\`\`\`\1/g
s/{{{class=&quot;\([^&quot;]*\)&quot;/\`\`\`\1/g
s/{{{/\`\`\`/g
s/}}}/\`\`\`/g
s/\[\([^] ]\{1,\}\)\]\([^](]\)/![pic](\1)\2/g
s/\[\([^] ]\{1,\}\)\]$/![pic](\1)/g
s/\[\[\(\([^|]\{1,\}\)\|\)\([^]]\{1,\}\)\]\]/[\3](\2.md)/g
s/\[\[\([^]]\{1,\}\)\]\]/[\1](\1.md)/g
s/\[\(https\{0,1\}:\/\/[^ ]*\) \([^]]*\)\]/[\2](\1)/g
s/%% \(.*\)/&lt;!-- \1 --&gt;/g
/%toc.*/d
s/%title \(.*\)/# \1/g
s/%nohtml/- status: draft/g</pre>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[阿里巴巴三年醇]]></title>
        <link href="http://blog.hotoo.me/post/alibaba-3-years"/>
        <published>2014-02-25T00:00:00.000Z</published>
        <updated>2014-02-25T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/alibaba-3-years</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p>今天 <a href="https://github.com/lifesinger">@玉伯</a> 给我送来的三年醇礼物。</p>
<p>一个阿里真棒玉坠。</p>
<p><img src="https://f.cloud.github.com/assets/143572/2257303/db0a08fa-9e16-11e3-90b3-5b9cea307a2a.png" alt="阿里真棒"></p>
<!--more-->

<p>三周年成（阿里）人手印礼。</p>
<p><img src="https://f.cloud.github.com/assets/143572/2257320/2a17e296-9e17-11e3-98f8-6a45a91ffcf5.png" alt="手印礼"></p>
<p>和女朋友一起用手印礼多出来的印泥自制的小猪猪。</p>
<p><img src="https://f.cloud.github.com/assets/143572/2257321/37011bda-9e17-11e3-9f28-36c0391f505a.png" alt="印泥手工制品"></p>
<p>感谢阿里。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[中国农历]]></title>
        <link href="http://blog.hotoo.me/post/lunar-calendar"/>
        <published>2013-11-13T00:00:00.000Z</published>
        <updated>2013-11-13T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/lunar-calendar</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p>Google 日历内置了中国农历的支持，但是各种桌面客户端如 Mac iCal, iPhone 默认日历
都无法正常使用，网上搜索了一遍也没有更好的订阅地址，大都不更新了。</p>
<p>而且我又不想装各种乱七八糟的第三方日历应用。</p>
<p>因此我自己制作了一个公开农历日历，需要的同学可以订阅到 Google Calendar，并且在
Google Calendar 中可以隐藏这个日历，只是在各个客户端中显示即可。</p>
<p>不过不爽的是，客户端不能针对特定日历设置提醒，有更好的方案的同学欢迎指教哈。</p>
<!--more-->

<h2 id="启用-google-calendar-内置农历（推荐）">启用 Google Calendar 内置农历（推荐）</h2><ol>
<li><p>设置(Settings)</p>
<p><img src="../../images/google-calendar-settings.png" alt="Settings"></p>
</li>
<li><p>基本(General)</p>
</li>
<li><p>备用日历(Alternate calendar)</p>
<p><img src="../../images/google-calendar-settings-alternate-calendar.png" alt="Alternate calendar"></p>
</li>
<li><p>选择 <code>农历 - 简体中文</code> (<code>Chinese calendar - Simplified Chinese</code>)</p>
</li>
<li>保存(Save)</li>
<li><p>最终可以在每日的日历顶部，有对应农历的显示。</p>
<p><img src="../../images/google-calendar-lunar-calendar-demo.png" alt="农历月历演示"></p>
</li>
</ol>
<hr>
<p>Google 日历的这个特性真是太赞了，以前为每天创建一个全天日历的挫 B方案没脸比。</p>
<p>不过，现有的桌面（包括移动设备）应用中，都没能很好的支持这个特性。我又不想安装
第三方的乱七八糟的日历应用，希望一个日历应用管理所有的日历数据，希望数据是开放的。</p>
<p>因此挫 B 的方案只能继续。</p>
<p>通过互联网在整个世界找了一圈，分享出来的农历订阅日历都已经失效、或者不更新了，
因此我决定自己来维护世界和平，创建并分享了下面的中国农历，大家只需要订阅
到自己的日历中就可以了。</p>
<h2 id="订阅地址">订阅地址</h2><ul>
<li><a href="https://www.google.com/calendar/ical/896414ier7cs228f2fp4mkn02g%40group.calendar.google.com/public/basic.ics">ical</a></li>
<li><a href="https://www.google.com/calendar/feeds/896414ier7cs228f2fp4mkn02g%40group.calendar.google.com/public/basic">xml</a></li>
<li><a href="https://www.google.com/calendar/embed?src=896414ier7cs228f2fp4mkn02g%40group.calendar.google.com&amp;ctz=Asia/Shanghai">html</a></li>
</ul>
<h2 id="订阅方法">订阅方法</h2><p>桌面应用本身支持直接订阅 ical 日历，但是为了便于管理，我统一使用了 Google Calendar
管理我的日历，桌面应用只是客户端，数据来源于 Google Calendar。</p>
<ul>
<li><p>Other calendars 右侧的菜单，选择 <code>Add by URL</code></p>
<p><img src="../../images/google-calendar-add-by-url.png" alt="Add Calendar"></p>
</li>
<li><p>填入 ical 地址：</p>
<p><code>https://www.google.com/calendar/ical/896414ier7cs228f2fp4mkn02g%40group.calendar.google.com/public/basic.ics</code></p>
<p><img src="../../images/google-calendar-add-calendar.png" alt="Add Calendar"></p>
</li>
<li><p>点击 Add Calendar 按钮。</p>
</li>
<li>由于 Google Calendar 本身内置了农历的支持，可以在 Google Calendar 中隐藏不显示这个日历。</li>
</ul>
<p>预览：</p>
<iframe src="https://www.google.com/calendar/embed?height=600&amp;wkst=1&amp;bgcolor=%23FFFFFF&amp;src=896414ier7cs228f2fp4mkn02g%40group.calendar.google.com&amp;color=%23875509&amp;ctz=Asia%2FShanghai"
  style=" border-width:0 " width="800" height="600" frameborder="0" scrolling="no"></iframe>

<h2 id="其他">其他</h2><ul>
<li>如果在使用过程中发现其中的错误，请邮件给我。</li>
<li>同时欢迎 Fork 这个 <a href="https://github.com/hotoo/chinese-lunar-calendar">『中国农历』开放项目</a> 。
或者给我们提交 Issues。</li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[Vim Talk in 来往扎堆]]></title>
        <link href="http://blog.hotoo.me/post/vim-talk-laiwangzhadui"/>
        <published>2013-10-23T00:00:00.000Z</published>
        <updated>2013-10-23T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/vim-talk-laiwangzhadui</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <blockquote>
<p>首先感谢支持加我的『来往』好友们，你们太让人感动了。</p>
</blockquote>
<p>经过一阵狂热，下面开始冷静正常的使用来往，好好利用这个应用。</p>
<p>扎堆是一个类似贴吧、论坛类信息分享交流的移动平台。
大家可以在这里随时随机的分享话题、信息、图片等，
也可以对他人发起的话题进行回复交流。</p>
<p><img src="/images/vim-talk-laiwangzhadui.png" alt="二维码"></p>
<p>欢迎加入 Vim Talk 扎堆，一起聊些有用有趣的技术话题。</p>
<p>加入方法：</p>
<ol>
<li>安装并启动 <a href="https://www.laiwang.com/">来往</a> 客户端。</li>
<li>打开『通讯录』-『添加好友』-『扫一扫加好友』-扫描上面的二维码即可。</li>
</ol>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[不缓存 CDN 静态资源方案]]></title>
        <link href="http://blog.hotoo.me/post/no-cache-in-cdn"/>
        <published>2013-09-21T00:00:00.000Z</published>
        <updated>2013-09-21T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/no-cache-in-cdn</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <h2 id="背景">背景</h2><p>支付宝目前使用淘宝提供的 CDN 服务，这个服务中的 CDN 节点在自身找不到对应资源时
主动到源服务器拉取的策略。</p>
<p><img src="/images/no-cache-in-cdn.png" alt="图"></p>
<p>支付宝使用的静态资源合并(combo)方案，导致在不同的访问参数情况下，被认为是不同
的静态资源。如果挟带的是避免缓存的随机参数，CDN 在没有缓存这个资源的情况下，
会到源服务器拉取资源。</p>
<p>原则上，我们使用特定的版本机制，每个新版本文件以不同的文件名发布，不允许使用
参数，尤其是随机数方式避免缓存问题。</p>
<h2 id="问题">问题</h2><p>由于我们使用的版本策略，我们可以指定用户缓存静态资源时效为永久，实际方案上
我们指定用户缓存时间为 1年，但是在某些场景下（如测量用户网络速度），
用户客户端（非 CDN 节点）访问某些特定静态资源需要禁止使用缓存。</p>
<p>目前常见的方案都是在客户端使用时间戳+随机数。这个方案本身看似没什么问题，但是
实际上有非常大的隐患，测量的数据参考性也不佳。</p>
<ul>
<li>CDN 节点上缓存了大量挟带永不重复随机数的资源，对磁盘造成影响。</li>
<li>CDN 缓存命中率降低，这些挟带随机数的静态资源缓存率命中率为 0。</li>
<li>增加源服务器的访问压力。</li>
<li>测量的用户网络响应时间实际不是到 CDN 节点的，还包含 CDN 回源的时间。</li>
</ul>
<!--more-->

<h2 id="解决方案">解决方案</h2><p>为了解决这种明确不允许用户客户端缓存，同时又不建议使用随机参数访问的需求，我们
有以下几种方案：</p>
<ol>
<li><p>CDN 服务器端控制浏览器不缓存。『最佳方案』</p>
<p>设置指定目录下的静态资源禁止缓存头信息，有需要禁止缓存需求时上传静态资源到
这个目录。</p>
</li>
<li><p>直接访问源服务器。</p>
<p>现在的加随机数访问 CDN 方案和直接访问源服务器本质上相同，这方案只能测用户到
源服务器的响应时间。</p>
</li>
<li><p>使用有限随机数方案。</p>
<p>虽然第一种是最佳方案，但也不排除某些浏览器或壳在不关闭页面情况下，有缓存的
问题，所以这和第一种方案结合使用可能是更靠谱一些的方案。『待验证』</p>
<p>页面脚本请求静态资源时，带上从零递增的参数，避免单页面缓存问题，亦可避免
CDN 缓存大量无意义资源的问题。</p>
</li>
</ol>
<h2 id="延伸">延伸</h2><p>实际上，对于静态资源来说，纯粹的参数是无意义的，CDN 节点本可以忽略这个参数。
虽然合并策略使用了参数方式，但是我们使用双问号激活合并服务的方案可以让我们
明确区分出合并参数和其他参数，因此技术上是完全可以忽略其他参数导致的回源。</p>
<h2 id="参考">参考</h2><ol>
<li><a href="http://segmentfault.com/q/1010000000119794">拉取式相比推送式的对比的参考</a></li>
</ol>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[每周异常：第 9期，搜狗浏览器中神一样的 try/catch 特性]]></title>
        <link href="http://blog.hotoo.me/post/weekly-topic-about-exceptions-9"/>
        <published>2013-09-13T00:00:00.000Z</published>
        <updated>2013-09-13T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/weekly-topic-about-exceptions-9</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <h2 id="背景">背景</h2><p>某日 16时 30分，监控实时大盘中全站 JavaScript 异常和 404 异常分别朝着不同的方向延伸，
橙色的 JavaScript 异常急剧上升。</p>
<p><img src="https://f.cloud.github.com/assets/143572/1136611/435cbfac-1c48-11e3-8856-8fc7ef13ce5a.png" alt="bac3c01389cadbb12d4873520b3bd2a9"></p>
<p>详细数据中我们看到一向高标准高质量的收银台出现异常大量的异常。</p>
<p><img src="https://f.cloud.github.com/assets/143572/1136701/ae74db38-1c4a-11e3-9d2d-1101c0b61a79.png" alt="2013-09-13 4 00 58"></p>
<h2 id="排查">排查</h2><p>我们发现其中有两个页面异常最多，而这两个页面中异常最多的『一个异常』详情如下：</p>
<ul>
<li>File: 同页面 URL</li>
<li>Line: 1</li>
<li>Message: Uncaught SyntaxError: Unexpected token a</li>
</ul>
<p>客户端信息：</p>
<ul>
<li>pc/-1;windows/5.1;sg/2.x;webkit/535.1</li>
<li>pc/-1;windows/6.1;sg/2.x;webkit/535.1</li>
</ul>
<p>堆栈信息：</p>
<pre>at function parse()
    at function ()
    at function (data)
    at function ()
    at function ()</pre><p>分析过程非常艰辛，重现异常的过程也是一波三折，这里不做赘述，最终分析得出：</p>
<ul>
<li>搜狗浏览器的 userAgent 太坑爹，几乎所有版本都是 2.x，开发者太不专业了。最终找到内核为 webkit/535.1 的是 3.2 版。</li>
<li><p>重现到老版 arale 中的 ajax 模块中对 JSON 有特殊的处理，如果浏览器内置的 JSON 不支持非标准的 JSON （如 <code>{a:1}</code>）则 hack 做兼容。</p>
<div class="highlight"><pre><code class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">W3CParse</span><span class="params">(data)</span> {</span>
        <span class="keyword">if</span> (validJSON(data)) {
            <span class="keyword">return</span> window.JSON.parse(data)
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> <span class="literal">null</span>;
            arale.error(<span class="string">"Invalid JSON: "</span> + data)
        }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">defaultParse</span><span class="params">(data)</span> {</span>
        <span class="keyword">if</span> (validJSON(data)) {
            <span class="keyword">return</span> (<span class="keyword">new</span> Function(<span class="string">"return ("</span> + data + <span class="string">")"</span>))()
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> <span class="literal">null</span>;
            arale.error(<span class="string">"Invalid JSON: "</span> + data)
        }
    }
    <span class="keyword">var</span> ok_wrong_json = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">try</span> {
            JSON.parse(<span class="string">"{ a: 1 }"</span>);
            <span class="keyword">return</span> <span class="literal">true</span>
        } <span class="keyword">catch</span> (x) {
            <span class="keyword">return</span> <span class="literal">false</span>
        }
    };
    <span class="keyword">if</span> (window.JSON &amp;&amp; window.JSON.parse &amp;&amp; ok_wrong_json()) {
        parseJSON = <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span>
            <span class="keyword">return</span> W3CParse.call(<span class="keyword">this</span>, data)
        }
    } <span class="keyword">else</span> {
        parseJSON = <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span>
            <span class="keyword">return</span> defaultParse.call(<span class="keyword">this</span>, data)
        }
    }</code></pre></div></li>
<li>抛出异常的代码是 <code>JSON.parse(&quot;{a: 1}&quot;)</code></li>
<li>但奇怪的是这段代码是放在 try/catch 中，为什么还会有异常被监控捕获？</li>
<li>最终发现这是搜狗浏览器 3.2版极速(webkit)模式中的特性：即使 try/catch 住的异常，
同样会被 window.onerror 捕获，但并未因此中断业务逻辑，后续的代码仍然会按照正确的
try/catch 异常处理流程进行，所以对业务本身没有影响。</li>
<li>p.s. 搜狗浏览器没有控制台，用户不会知道出了异常。</li>
<li>另外收银台之前异常量少的主要原因是主要的页面没有引入前端监控，用户抛出了异常而我们不知道而已。</li>
</ul>
<h2 id="相关截图">相关截图</h2><p><img src="https://f.cloud.github.com/assets/143572/1136977/316cd2d8-1c51-11e3-9f7e-4bbebec06108.png" alt="2013-09-13 4 39 14">
<img src="https://f.cloud.github.com/assets/143572/1136980/32da28aa-1c51-11e3-8dc4-5773fc84f885.png" alt="2013-09-13 4 39 33">
<img src="https://f.cloud.github.com/assets/143572/1136981/331bb9f0-1c51-11e3-93bf-8cd2dcdf5d7f.png" alt="2013-09-13 4 40 26">
<img src="https://f.cloud.github.com/assets/143572/1136982/331f90c0-1c51-11e3-8d08-8d61c08512dc.png" alt="2013-09-13 4 40 12">
<img src="https://f.cloud.github.com/assets/143572/1136983/332ad480-1c51-11e3-991f-b4b0db932f69.png" alt="2013-09-13 4 41 03"></p>
<h2 id="解决方案">解决方案</h2><p>最初虽然有些争议，但我们最终决定的处理方案是监控中临时排除 sg/2.x|webkit/535.1 中
<code>Uncaught SyntaxError: Unexpected token a</code> 异常。</p>
<h3 id="是否要排除这个浏览器中所有的异常？">是否要排除这个浏览器中所有的异常？</h3><p>呃，考虑到搜狗浏览器的份额，我们的策略是只排除已知的异常，未知的异常看最终分析结果再考虑。</p>
<h2 id="广告">广告</h2><p>这个异常排查的主要功臣 @wsvn53，我们在排查过程中频繁使用了他开发的工具
<a href="https://github.com/wsvn53/fedit">Fedit</a>，可以直接修改线上代码。
排查线上故 障、线下接⼝什么的都非常⽅方便。强烈建议⼤家都装上⽤用。</p>
<h2 id="最后">最后</h2><p>我仅代表我自己，想说某些毫无责任心的国产浏览器壳厂商们，你们没有创造价值，
只是在各种不同方式的索取。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[每周异常：第 8期，异常象限]]></title>
        <link href="http://blog.hotoo.me/post/weekly-topic-about-exceptions-8"/>
        <published>2013-09-05T00:00:00.000Z</published>
        <updated>2013-09-05T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/weekly-topic-about-exceptions-8</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p>上周的 <a href="weekly-topic-about-exceptions-7">每周异常：第 7期，保持简单，保持拙朴</a>
中介绍了通过页面关键的 URL/ID 信息，简单有效的发现异常的方案。
本周我们在这个异常分析方法之上，再稍微深入下：</p>
<p>对于整个网站来说，每个系统、页面是有重要级别的，比如支付宝收银台就是 A1 级系统。
这些系统、页面一般可以按照以下方法来判断重要性：</p>
<ul>
<li>访问量极大，是最主要的业务，对用户影响极大。</li>
<li>用户本身重要（例如商户，尤其是大商户），是最重要的业务，对企业影响巨大。</li>
</ul>
<p>对于前者，我们可以通过系统、域名的访问量来近似的划分；
对于后者，我们可以建立白名单机制。</p>
<p>对于异常来说，可以通过异常率来判断异常自身的紧急程度。</p>
<hr>
<ul>
<li>系统、页面重要性作为『异常重要性』的一个指标。</li>
<li>异常率及异常量作为『异常紧急程度』作为一个指标。<ul>
<li>异常率超过阈值的为高发率异常。</li>
<li>（可选）异常量超过阈值的也是高发量异常。</li>
<li>并且以高发率为主。</li>
</ul>
</li>
</ul>
<p>我们画出以下异常象限：</p>
<p><img src="/static/images/quadrant.png" alt="异常象限"></p>
<ul>
<li>图中一、二、三、四为象限代号。</li>
<li>(0, 1, 2, 3) 为异常重要性序号。</li>
</ul>
<p>经过一些分析，我们可以得出结论：</p>
<ul>
<li>第一、第二象限的异常，是我们最需要关注的部分。尤其是第一象限的异常，
实时高发异常一般也是在这个象限。</li>
<li>第四、三象限的低发异常，则几乎可以不用关注。</li>
<li>总之我们只需要关注高发异常，但应该以页面的重要性来排优先级。</li>
</ul>
<h2 id="如何设定阈值？">如何设定阈值？</h2><p>要确定异常象限，确定各个阈值是关键，这里只提供一些简单的参考。</p>
<ul>
<li>重要程度：全站重要页面占全站所有页面的 5% 左右，可以根据自身情况调整。</li>
<li>紧迫程度：<ul>
<li>目前的经验数据是异常率 4‰ 以上可以认为是高发率异常，但仍需继续
分析实际数据做调整。</li>
<li>（可选）异常 PV 超过 (全站访问最高页面 PV 乘以 1‰) 的也可以认为是高发量异常，
实际可以根据自身情况调整。</li>
</ul>
</li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[每周异常：第 7期，保持简单，保持拙朴]]></title>
        <link href="http://blog.hotoo.me/post/weekly-topic-about-exceptions-7"/>
        <published>2013-08-28T00:00:00.000Z</published>
        <updated>2013-08-28T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/weekly-topic-about-exceptions-7</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <h2 id="副标题：如何简单有效的发现最重要的有效异常">副标题：如何简单有效的发现最重要的有效异常</h2><blockquote>
<p>Keep It Simple, Stupid.</p>
<p>-- U.S. Navy (1960)</p>
</blockquote>
<p>在这之前，我一直苦苦寻求牛逼的算法 <a href="https://github.com/totorojs/javascript-exception-archives/issues/17">#12</a> ，
来解决这个看似简单，其实不易；仿佛不易，最终简单的问题：
找出最重要的有效异常。</p>
<p>最早的时候，我们定义了『一个异常』由以下核心部分组成：</p>
<ul>
<li>URL: 异常所在页面。</li>
<li>File: 异常代码所在文件。</li>
<li>Line: 异常代码所在行数。</li>
<li>Message: 异常消息。</li>
</ul>
<p>这些是不变的，相同页面中，同一个异常代码文件同一行，异常消息相同的异常，我们可以近似的认为它是同一个异常。</p>
<!--more-->

<p>另外还定义了异常率：</p>
<ul>
<li>异常率(PV)：『一个异常』的 PV，除以这个异常所在页面的 PV。</li>
<li>异常率(UV)：『一个异常』的 UV，除以这个异常所在页面的 UV。</li>
</ul>
<p>于是我们通过 URL, File, Line, Message 四个核心信息来统计每一个异常的 PV, UV, PV异常率，UV异常率。
并按照其中的某个字段为主进行排序。</p>
<p>但是得到的结果总是让人不尽如人意，总会有很多无法排查，甚至还有一些显然不是我们代码的问题的异常排前排。</p>
<p>我们尝试限制异常 PV, UV 的基数，尝试限制页面 PV, UV 的基数，结果仍然不理想。
而且也没有想出其他牛逼的权重算法来评估每个异常。</p>
<p>我们想过异常是跟代码所在文件和行号、异常消息有关系的，跟页面 URL 的关系不那么强，因为公共代码会在很多页面使用，把这同一个异常分散算到不同页面中会严重影响这个异常的排名。</p>
<p>但是实际上公共代码（尤其是基础类库）的异常很多情况下是业务系统调用不当，或者使用的版本有 BUG 导致，最终还是需要这个页面的开发者调整调用方法，或升级使用更新的公共脚本来解决。所以忽略或弱化异常所在页面是不可接受的。</p>
<p>而且排除了异常所在页面的信息，对于排查异常来说更为困难。</p>
<p>够了，我已经受够了，脑袋一片浆糊。
累、困，早点回家睡觉。</p>
<hr>
<p>回到家随手画了几笔，然后去洗澡。洗澡的时候想着刚刚画的思维草图，逐渐想清楚了很多。</p>
<ul>
<li>File: 由于是 seajs 自动管理依赖，以及 combo 的使用，异常所在文件本身具有不稳定性。</li>
<li>Line: 由于上面 File 的原因，不仅仅是 HTML 代码中的异常行号不稳定，静态脚本异常行号也具有不稳定性。</li>
<li>Message: 不同浏览器（包括不同版本，或者在不同操作系统中）对同一个异常有不同的消息反馈，另外还有本地化的原因，异常消息也具有不稳定性。</li>
</ul>
<p>最后，只有异常所在页面 URL（或者页面 ID，一个页面源文件可能有多个 URL 地址，但是它们是有关系的，ID 相同）才是最稳定的。</p>
<hr>
<p>于是我根据页面 URL 排列出每个页面的异常 PV, UV, PV异常率，UV异常率。并根据 PV 异常率为主进行倒序排序（每次访问都抛出的异常，比每个用户访问都抛出的异常的优先级更高）于是我们轻易得出了全站异常率最高的页面。</p>
<p>根据这个关键的页面信息，再次查询出每『一个异常』的 PV, UV, PV异常率，UV异常率。</p>
<p>以不变（页面 URL 或 ID），应万变。我们一个个把这些异常大户揪出来，各个击破。即使暂时没有发布解决，我们仍可以轻易识别排除这个已经揪出的异常。</p>
<p>好了，妈妈再也不用操心我的每周异常 TOP 数据分析了。</p>
<p>嗯， <a href="https://github.com/totorojs/javascript-exception-archives/issues/17">#12</a> 这个 issue 也可以关了。</p>
<hr>
<p>在做静态资源异常监控时，也有类似的经历。</p>
<p>静态资源监控最重要的是发现哪个页面引用了哪个 404资源，尤其是漏发的资源。因此最重要的有两个关联维度：</p>
<ul>
<li>404资源所在页面</li>
<li>404资源文件地址</li>
</ul>
<p>但是引起 404 的场景很多，包括：</p>
<ul>
<li>漏发文件。</li>
<li>静态引用地址错误。</li>
<li>动态引用地址错误。</li>
</ul>
<p>其中动态引用是由于动态脚本计算得出的静态资源地址，引发的 404 非常频繁，多样、而且分布的很散。因此这两个维度的排列组合结果就非常巨大。而且我们的分析系统是基于索引的，这些内容不确定、数量庞大的指标非常不适合用这个系统分析。（我们还有另一个非常时候实时异常分析的系统，这里不做介绍）</p>
<p>因此我们把重心放在更为稳定的页面 URL，只关注出现 404 的页面，至于是什么资源可以直接根据 URL 查询日志，或直接访问这个页面。</p>
<h2 id="小结">小结</h2><p>这篇讲的几个关键内容再强调下：</p>
<ul>
<li>保持简单，保持拙朴。</li>
<li>抓住重点，真正的核心重点。</li>
</ul>
<hr>
<p>终于可以睡了，晚安~</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[每周异常：第 6期，JavaScript 异常监控脚本引发的 JavaScript 异常]]></title>
        <link href="http://blog.hotoo.me/post/weekly-topic-about-exceptions-6"/>
        <published>2013-08-22T00:00:00.000Z</published>
        <updated>2013-08-22T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/weekly-topic-about-exceptions-6</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <h2 id="背景">背景</h2><p>早上收到比较重要的用户反馈说某个重要的系统的页面在 IE 浏览器中卡死，无法继续。</p>
<p><img src="https://f.cloud.github.com/assets/143572/1007567/5214e9b4-0b0b-11e3-8d43-07d34947d198.png" alt="2013-08-22 5 14 01">
<img src="https://f.cloud.github.com/assets/143572/1007568/523e63de-0b0b-11e3-85bd-b3adee635aef.png" alt="2013-08-22 5 14 25"></p>
<p>问题很严重。</p>
<p>系统比较特殊复杂，不是一般人能登录进去的。找到对应同学在小概率重现的情况下终于拿到了第一手的问题源码。</p>
<h2 id="分析">分析</h2><p>修改配置和采样率之后在本地跑起来，发现在 IE6 里非常有问题。</p>
<ol>
<li>性能这么大的问题，首先想到的是页面中大面积扫描 HTML 代码的部分，但是注释掉这部分仍然没有改善。</li>
<li>再次把整个回调处理函数注释掉，仍然没有改善。</li>
<li>直接把加载后置脚本的 seajs.use 注释掉之后，终于没问题了。（坑爹的缓存问题就不说了，好久之后才发现，都是泪~）</li>
<li>这么看来有两种可能：<ol>
<li>模块本身有性能问题。</li>
<li>seajs 性能有问题（这个问题页面目前使用的 1.3.1）</li>
</ol>
</li>
<li>首先考虑自身的问题。return 整个 factory，性能无问题，因此不是模块过多导致 seajs 性能问题。</li>
<li><p>逐步修改 return 位置（其实可以打断点），终于发现问题出在 <a href="https://github.com/totorojs/monitor.js/blob/2.2.0/src/monitor.js#L23">初始化事件绑定函数部分</a>。</p>
<p><!-- baseline:11 --></p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// 避免未引用先行脚本抛出异常。</span>
<span class="keyword">if</span>(!win.monitor){
  M = win.monitor = {};
  M._DATAS = [];
  M._EVENTS = [];
}

<span class="keyword">var</span> _events = M._EVENTS;
<span class="keyword">var</span> _evt = <span class="keyword">new</span> Events();
M.on = <span class="function"><span class="keyword">function</span><span class="params">(evt, handler)</span>{</span>
  _evt.on(evt, handler);
};
<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,l=_events.length; i&lt;l; i++){
  M.on(_events[i][<span class="number">0</span>], _events[i][<span class="number">1</span>]);
}</code></pre></div></li>
<li>此时 _events = undefined。访问 undefined.length 或其他属性会导致浏览器挂起？ IE6 还有这样的坑？</li>
<li>新建一个最小代码的新页面，直接 <code>script[src]</code> 引入这个脚本没有问题，IE 会正常的抛出异常，不会挂起。</li>
<li>动态创建 script 插入脚本，仍然不会挂起，正常抛出异常。</li>
<li>奇怪。各种尝试，最终加入前置脚本后在这个最小重现代码中重现了异常。</li>
<li>然后发现是在 window.onerror 中出现问题。</li>
<li>继续发现的模拟调用栈信息的算法出现问题。</li>
</ol>
<p>cmd 模块在 define 的 factory 中本身抛出异常，会被前置脚本的 window.onerror 捕获，捕获过程中尝试 <a href="https://github.com/totorojs/monitor.js/blob/2.2.0/src/seer.js#L66">还原函数调用栈</a>。模拟还原调用栈信息是通过 arguments.callee.caller 向上递归，直到找到函数调用的发起者。但是悲剧的是发现 seajs 这个调用栈是无穷无尽的：</p>
<pre>at function(require, exports, module)
at function runInModuleContext(fn, module)
at function()
at function(uri)
at function(item, i, arr)
at function(arr, fn)  ........-
at function(arr, fn)          |
at function()                 |
at function preload(callback) |
at function()                 |
at function cb(module)        |
at function onFetched()       |
at function(fn)       ........-
at function(arr, fn)    ..........-
at function(arr, fn)              | 循环往复
at function()                     |
at function preload(callback)     |
at function()                     |
at function cb(module)            |
at function onFetched()           |
at function(fn)         ..........-
at function(arr, fn) .........-
at function(arr, fn)          | 无穷尽也
at function()                 |
at function preload(callback) |
at function()                 |
at function cb(module)        |
at function onFetched()       |
at function(fn)         ......-</pre><p>这也就是为什么用户的浏览器会挂起的原因。</p>
<hr>
<h3 id="小结">小结</h3><p>用户浏览器被挂起，最终发现：</p>
<ul>
<li>不是扫描整个文档的性能问题。</li>
<li>不是 seajs 加载多个模块的性能问题。</li>
<li>主要不是 cmd define 中报错的问题。</li>
<li>不是 window.onerror 捕获异常的问题。</li>
<li>而是获取异常函数调用栈出现无限循环链的问题，</li>
<li>这其实是 IE 的问题。</li>
<li>好吧，最终还是我的问题。</li>
</ul>
<h2 id="监控脚本自身的-cmd-模块定义的异常是怎么出现的？">监控脚本自身的 cmd 模块定义的异常是怎么出现的？</h2><p>monitor 2.2.0 新增了 <a href="https://github.com/totorojs/monitor.js/issues/18">事件机制</a>，支持监控任意的自定义数据。</p>
<p>其中在前置脚本中新增了 <code>monitor.on()</code> 方法，将自定义事件处理函数临时存储在 <code>monitor._EVENTS</code> 属性中 <a href="https://github.com/totorojs/monitor.js/blob/2.2.0/src/seer.js#L18">参考代码</a> 。后置脚本加载完成后，会复写 <code>monitor.on()</code> 方法，并将之前用户自定义事件处理函数绑定到对应事件，以使事件机制生效。</p>
<p>这些理论上都是非常不错的设计思路。</p>
<p>但是现实太残酷，全站公共区域被实际部署的情况有太复杂：</p>
<ol>
<li>有些系统没有完全引入前置脚本。</li>
<li>有些系统仍然引用的老版本的前置脚本。</li>
</ol>
<p>后置脚本对于后面的这个场景没有考虑到，因此这段保险栓未能正确执行导致后续脚本报错。</p>
<h2 id="为什么这个异常会到生产环境？">为什么这个异常会到生产环境？</h2><p>都是我的错，没有考虑周全。没有考虑到这种特殊的系统部署环境，而且我也从来不能进去实际体验、验证。</p>
<h2 id="如何处理这个异常？">如何处理这个异常？</h2><ol>
<li>作为全站全局运行的代码，要详细评估考虑到各种系统变态的部署环境。</li>
<li>打断循环调用栈<ol>
<li>限制监控的最大函数调用栈深度。</li>
<li>对于已经调用的栈，不再深入递归，或现在递归次数（待评估，实际项目存在正常的递归或多次调用的代码。）</li>
</ol>
</li>
</ol>
<h2 id="为什么-seajs-define-模块中报错会出现函数调用栈无限递归？">为什么 seajs define 模块中报错会出现函数调用栈无限递归？</h2><p>这是 seajs 1.3.1 的 BUG，更准确的说，可能是 IE6,7,8闭包的问题。参考： <a href="https://github.com/seajs/seajs/issues/911">https://github.com/seajs/seajs/issues/911</a></p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[每周异常：第 5期，由静态资源异常引发的质疑]]></title>
        <link href="http://blog.hotoo.me/post/weekly-topic-about-exceptions-5"/>
        <published>2013-08-16T00:00:00.000Z</published>
        <updated>2013-08-16T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/weekly-topic-about-exceptions-5</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p>今天要说的是一个『静态资源异常监控』的话题。虽然静态资源异常可以非常有效的跟
JavaScript 异常结合起来做有力的分析，但是今天这个话题跟 JavaScript 异常没什么关系。</p>
<hr>
<p>传说某著名公司的网站监控方案是申请了专利的技术，我有幸看到过，真的是非常牛逼。</p>
<p>这个网站监控方案中提供了网页的访问量、页面访问流向、页面有效点击量、点击热图，
灰度发布（包括 ABTest）等都有完善的支持。</p>
<p>这个方案总体上是用 JavaScript 通过 new Image() 发送监控的数据到日志服务器，
然后由数据仓库做数据清洗。</p>
<p>通过业务系统服务器端的日志分析，这套方案的数据质量有确实有一定的问题，
比如它统计到的访问量要比业务系统服务器端统计到的少，丢失率一般在 5% ~ 10% 左右，
少量特殊页面（比如跳转页）丢失率会高达 50% ~ 60%。</p>
<p>尽管如此我们也基本上可以接受这样的误差，而且部分从理论上讲，『应该』大部分是
无效或无意义的访问（比如爬虫、快速跳转等），丢掉是合理的。</p>
<p>一直以来，我们都认为这个方案的数据是相对比较可靠的，虽然偶尔有些不正常的丢失率
让业务方质疑，但是我们总是用上面的理论和理由解释给对方听，让他们接受我们的现实。</p>
<p>这样过了好多年，他们过着幸福的生活~</p>
<hr>
<p>直到有个家伙的膝盖被射了一箭，搞出来个静态资源监控系统。</p>
<p>静态资源监控系统是通过分析静态服务器的访问日志，来统计各个资源状态的趋势及其分布情况。</p>
<p>因为静态资源监控是通过静态服务器访问日志来分析的，理论上和业务服务端的日志是一致的。</p>
<p>但是我们惊奇的发现某个静态页面引用了某个不存在的静态资源，异常率理论上应该是 100%，
但是对照网站监控方案统计的数据发现，这个静态资源异常率高达 200%。</p>
<p>我的第一直觉是网站监控丢失率高达 50%。遂跟网站监控相关同学沟通，然后他们第一反映
是质疑我对他们的质疑。</p>
<p>让业务服务端同学统计日志发现他们的访问量确实要大于网站监控访问量，但又小于静态资源异常量。</p>
<p>我虽然毫不怀疑自己的数据，但一时也无法质疑业务服务端的数据。</p>
<p>业务服务端同学随意说了一句：『难道有缓存？』</p>
<p>于是这个疑惑破解了：</p>
<ol>
<li>用户访问页面时，有一部分可能是读取的本地缓存，这部分业务服务端无法统计到。</li>
<li>有些读取缓存的场景不会执行初始化 JavaScript，这些场景网站监控没有统计到。</li>
<li>外联的 404 资源是不会被缓存的。</li>
</ol>
<p>因此这些有缓存的静态页面（这个知名公司有不少页面是这种纯静态、伪静态页面）的场景下，使用 JavaScript 发送监控的监控手段目前丢失率是 50% 左右。</p>
<h3 id="参考">参考</h3><ul>
<li><a href="http://stackoverflow.com/questions/3674830/caching-problem-with-asynchronous-javascript-loading-with-onload-event">Caching problem with asynchronous javascript loading with onload event</a></li>
<li><a href="http://www.360doc.com/content/11/1219/17/2633_173430718.shtml">IE6 加载不执行 JS</a></li>
<li><a href="http://www.360doc.com/content/12/0306/16/2633_192235974.shtml">IE6 加载不执行 JS 2</a></li>
<li><a href="http://blog.csdn.net/mlitest/article/details/7368712">因为缓存Page_Load不执行的情况</a></li>
<li><a href="http://segmentfault.com/q/1010000000123673">Opera在点击回退按钮后，原来页面的js都不执行了吗?</a></li>
<li><a href="http://monket.net/blog/2010/02/detecting-when-a-page-is-loaded-from-the-browser-cache/">Detecting when a page is loaded from the browser cache</a></li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[每周异常：第 4期，如何避免客户端攻击造成的大量异常报警]]></title>
        <link href="http://blog.hotoo.me/post/weekly-topic-about-exceptions-4"/>
        <published>2013-08-07T00:00:00.000Z</published>
        <updated>2013-08-07T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/weekly-topic-about-exceptions-4</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p>在 JavaScript 异常监控过程中，发现有很多由于客户端连续攻击造成的大量异常，导致
监控系统报警。</p>
<p><img src="https://f.cloud.github.com/assets/143572/921735/fe39d910-ff04-11e2-93f2-ca5bb222be8f.png" alt="2013-08-07 9 58 37"></p>
<p>（图中大量不连续的波动，都是攻击造成的）</p>
<p>这种少量用户(UV)发起攻击造成的大量异常(PV)波动，不是我们实时监控需要关注的部分。
我们实时监控最重要的是要发现由于系统发布过程中，我们的发布的代码有问题导致大量
用户受影响而出现的波动（波形可能跟上图的每一个异常波形相似）。</p>
<p>理论上导致异常数据波动的场景包括：</p>
<ul>
<li>少量用户发起大量攻击。</li>
<li>大量用户同时涌入或离开。</li>
<li>发布问题代码影响到大量用户。</li>
</ul>
<p>少量用户发起大量攻击造成数据波动，是我们可以不必实时关注实时报警的部分。</p>
<p>大量用户同时涌入或离开造成的异常数量(PV)波动，也是我们无需实时关注的部分，
另外我们也可以通过异常率规避波动。</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>异常 PV</th>
<th>异常 UV</th>
<th>异常率(PV)</th>
<th>异常率(UV)</th>
</tr>
</thead>
<tbody>
<tr>
<td>攻击</td>
<td>波动</td>
<td>无波动</td>
<td>波动</td>
<td>无波动</td>
</tr>
<tr>
<td>涌入</td>
<td>波动</td>
<td>波动</td>
<td>无波动</td>
<td>无波动</td>
</tr>
<tr>
<td>发布</td>
<td>波动</td>
<td>波动</td>
<td>波动</td>
<td>波动</td>
</tr>
</tbody>
</table>
<p>注：</p>
<ul>
<li>异常率(PV) = 异常PV / 所在页面PV</li>
<li>异常率(UV) = 异常UV / 所在页面UV</li>
</ul>
<p>从上面的对照表可以看出，理论上我们只需要关注异常率(UV) 是否正常波动就可以了。</p>
<p>理想很性感，现实很骨感。</p>
<p>我们的数据仓库、数据分析系统对于实时 PV 有很强的处理能力，但是对于 UV 就感觉力有不逮。</p>
<p>起初想到在实时日志处理逻辑中使用缓存（伪代码）：</p>
<div class="highlight"><pre><code class="javascript">class LogParse(){

  <span class="keyword">var</span> user_cache = {};
  <span class="keyword">var</span> MINUTES_FORMAT = <span class="string">"YYYYMMDDHHmm"</span>;
  <span class="keyword">var</span> lastTime = moment().format(MINUTES_FORMAT);

  <span class="function"><span class="keyword">function</span> <span class="title">parse</span><span class="params">(log)</span>{</span>
    <span class="comment">// PV 统计</span>

    <span class="keyword">var</span> now = moment().format(MINUTES_FORMAT);
    <span class="keyword">if</span>(now !== lastTime){
      user_cache = {};
      lastTime = now;
    }
    <span class="keyword">if</span>(user_cache.hasOwnProperty(user_id)){<span class="keyword">return</span>;}
    <span class="comment">// UV 统计</span>
  }

}</code></pre></div><ul>
<li>但是实时数据分析系统是分布式的，由多台服务器组成的集群同时处理日志，所以里面
的内部状态只有本机有效</li>
<li>另外更致命的是，实时数据分析系统是无状态的，下次执行会 new 新的 LogParser 实例，
同一台机器的状态也保证不了。</li>
</ul>
<p>于是我们又想到一种从客户端来标识用户的方法：</p>
<ol>
<li>客户端单位时间内同一个页面抛出的同一个异常，第一次打上 uv 标记。</li>
<li>数据处理时遇到 uv 标记的日志，同时统计算做一个异常 uv。</li>
</ol>
<p>由于客户端时间和服务端有时间差，每个客户端时间和服务端时间差也不一致，导致这种
方案会有稍大误差，但也基本能解决问题。</p>
<p>但是要在客户端打标记，则需要在客户端（cookie 或其他本地存储）记录每个异常
（url, file, line, message 相同被当作同一个异常）最后抛出的时间，每次抛出异常
都需要读写本地存储，稍嫌臃肿。</p>
<p>通过深入分析实际的攻击案例，发现攻击引发大量异常的场景中，客户端页面是不刷新或
重新访问的，都是直接在当前访问的页面执行上批量脚本。</p>
<p>因此我们可以使用局部变量，将当前访问的页面的每个异常最后抛出时间记录在内存中，
重新访问页面则重新开始记录。</p>
<p>这种方案对于防范攻击造成的大量异常非常有效；对于大量用户涌入引起的异常也有一定
效用，毕竟正常用户较少会频繁触发异常。</p>
<p>总之，通过这个方案，我们可以非常有效的实时监控异常波动，较少误报。</p>
<p>p.s. 这个想法是早上洗澡的时候想到的，还没开始实践。但是我信心满满写下这篇，
数据会来证明我是对的。</p>
<h2 id="续-on-2013-08-20">续 on 2013-08-20</h2><p>是时候结帐了。正好发布一天，大家看数据：</p>
<p><img src="https://f.cloud.github.com/assets/143572/991796/2e2038c2-096e-11e3-9008-e21d3b9e354a.png" alt="2013-08-20 3 55 10"></p>
<p>图中的灰色竖线是发布点，橙色是 JavaScript 异常，绿色是静态资源异常。</p>
<p>妈妈再也不用担心我的手机会收到误报的报警短信了。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[每周异常：第 3期，宏观异常分析方法]]></title>
        <link href="http://blog.hotoo.me/post/weekly-topic-about-exceptions-3"/>
        <published>2013-08-02T00:00:00.000Z</published>
        <updated>2013-08-02T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/weekly-topic-about-exceptions-3</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p>为了有效的分析 JavaScript 异常，我们从宏观的统计数据中做了大量的分析，初步结果如下：</p>
<h2 id="全站每日异常统计">全站每日异常统计</h2><p>首先我们从每天的全站总体数据进行分析，得到下面这些报表。其中：</p>
<ul>
<li>all_pv: 全站所有有效异常次数 (PV)</li>
<li>all_uv: 全站所有有效异常人数 (UV)</li>
<li>all_pv_rate: 全站所有异常率 (按 PV 统计)</li>
<li>all_uv_rate: 全站所有异常率 (按 UV 统计)</li>
<li>valid_rate_pv: 有效异常率（按 PV 统计）</li>
<li>valid_rate_uv: 有效异常率（按 UV 统计）</li>
</ul>
<p><img src="https://f.cloud.github.com/assets/143572/900597/98aa3094-fb68-11e2-9f9e-c3809ea15b48.png" alt="2013-08-02 7 42 02"></p>
<p><img src="https://f.cloud.github.com/assets/143572/900599/ac59ccb2-fb68-11e2-89c3-4e0d6db7261f.png" alt="2013-08-02 7 42 37"></p>
<p><img src="https://f.cloud.github.com/assets/143572/900625/c145cbac-fb69-11e2-80c7-d1f9152ddeb4.png" alt="2013-08-02 7 50 11"></p>
<p><img src="https://f.cloud.github.com/assets/143572/900601/bbc1e3a6-fb68-11e2-85e7-b6443f502860.png" alt="2013-08-02 7 43 04"></p>
<p><img src="https://f.cloud.github.com/assets/143572/900602/cd4f7f0c-fb68-11e2-96b8-2de40b5d2882.png" alt="2013-08-02 7 43 31"></p>
<p>从趋势图中我们可以明显的看到第 2天和最后一天，异常 PV 有较大波动，这是由于用户
攻击爆发大量异常造成的。</p>
<p>我们在 <a href="https://github.com/totorojs/javascript-exception-archives/issues/12">异常评分算法</a>
的讨论中有提到，即使是少量用户进行攻击，异常 UV 也不应该有波动的（除非页面 UV
本身有较大波动），但是实际上我们看到最后一天的异常 UV 也有明显波动，因此粗略
分析这个异常 PV 的上升是由于页面访问人数增多造成的。</p>
<p>事后我们查了当天的页面访问 PV 和 UV，可惜并没有明显波动。</p>
<p>实际经过细致的异常日志分析，我们看到攻击用户同时没过一段时间就更换 IP 地址或清理
Cookie，因此全天的综合数据中异常 PV  和异常 UV 有了一些明显波动。</p>
<p>而且实际上，每天都有攻击造成的异常波动。</p>
<ul>
<li>每天都有攻击造成的异常，累加在一起好像每天都没什么问题。</li>
<li>由于攻击造成异常总数相对一天的异常总数太小，从全天异常总数的层面来看，
无法发现，甚至排除攻击造成的异常。</li>
<li>T+1 的统计数据，对于异常监控来说，太迟钝了。</li>
</ul>
<h2 id="全站每分钟异常统计">全站每分钟异常统计</h2><p>从上面每日异常总和的分析我们可以看出，一天的总和数据能发现的问题还是比较有限的。
于是我从分钟的粒度来统计异常。</p>
<p><img src="https://f.cloud.github.com/assets/143572/900781/7496f1e6-fb6e-11e2-854f-1a0f685bea15.png" alt="2013-08-02 7 24 54"></p>
<p>图有点大，点击可以看大图。</p>
<p>从图中我们可以看到，凌晨 2点多到 3点多期间，有少量用户发起了猛烈的攻击；
凌晨 4点多到凌晨7点多期间也有少量温和的攻击。攻击时全站异常 PV （绿色）
和全站有效异常（深红色）明显飙升，但是异常 UV 和有效异常 UV 都没有太大波动，
而且与前后的时间切片有较好的连贯性，没有大起大落。</p>
<p>而如果异常 UV 出现较大波动，在很可能是由于我们正在发布的新代码影响大面积用户。</p>
<p>合适的时间粒度对于及时发现真正有效的异常有非常重要的意义。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[每周异常：第 2 期（续）]]></title>
        <link href="http://blog.hotoo.me/post/weekly-topic-about-exceptions-2-2"/>
        <published>2013-07-23T00:00:00.000Z</published>
        <updated>2013-07-23T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/weekly-topic-about-exceptions-2-2</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p><a href="weekly-topic-about-exceptions-2">上篇</a> 分析了上周的异常 TOP4，顺便发现 TOP3
和 TOP5 是同一个问题造成的异常。</p>
<p>下面我们来分析 TOP1 和 TOP 2 的异常，事实上，这两个异常也是由同一个问题造成的。</p>
<h2 id="top1">TOP1</h2><table>
<thead>
<tr>
<th>KEY</th>
<th>VALUE</th>
</tr>
</thead>
<tbody>
<tr>
<td>URL</td>
<td><a href="https://www.example.com/index.htm">https://www.example.com/index.htm</a></td>
</tr>
<tr>
<td>File</td>
<td><a href="https://a.example.com/??seajs/1.3.1/sea.js,seajs/1.3.1/plugin-combo.js,jquery/jquery/1.7.2/jquery.js">https://a.example.com/??seajs/1.3.1/sea.js,seajs/1.3.1/plugin-combo.js,jquery/jquery/1.7.2/jquery.js</a></td>
</tr>
<tr>
<td>Line</td>
<td>35</td>
</tr>
<tr>
<td>Message</td>
<td>无法获取未定义或 null 引用的属性“length”</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>stack trace</th>
<th>device</th>
<th>os</th>
<th>browser</th>
<th>engine</th>
<th>count</th>
</tr>
</thead>
<tbody>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>ie/10.0</td>
<td>trident/6.0</td>
<td>2740</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>sg/2.x</td>
<td>trident/6.0</td>
<td>868</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.2</td>
<td>ie/10.0</td>
<td>trident/6.0</td>
<td>538</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>tao/3.2</td>
<td>trident/6.0</td>
<td>236</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>baidu/2.x</td>
<td>trident/6.0</td>
<td>113</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>tw/3.6.1.1</td>
<td>trident/6.0</td>
<td>36</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.2</td>
<td>tao/3.2</td>
<td>trident/6.0</td>
<td>26</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/4.0.5.2000</td>
<td>trident/6.0</td>
<td>25</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/4.1.0.2000</td>
<td>trident/6.0</td>
<td>20</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/4.0.6.2000</td>
<td>trident/6.0</td>
<td>15</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>na/-1</td>
<td>ie/10.0</td>
<td>trident/6.0</td>
<td>14</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/5.0</td>
<td>ie/10.0</td>
<td>trident/6.0</td>
<td>12</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/4.1.1.600</td>
<td>trident/6.0</td>
<td>10</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>tw/3.6.1.0</td>
<td>trident/6.0</td>
<td>10</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/4.0.3.1000</td>
<td>trident/6.0</td>
<td>8</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.2</td>
<td>mx/4.0.6.2000</td>
<td>trident/6.0</td>
<td>8</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>tao/3.0</td>
<td>trident/6.0</td>
<td>7</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/3.4.5.2000</td>
<td>trident/6.0</td>
<td>6</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>qq/6.14.15493.201</td>
<td>trident/6.0</td>
<td>6</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>qq/7.3.11251.400</td>
<td>trident/6.0</td>
<td>6</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/5.1</td>
<td>ie/10.0</td>
<td>trident/6.0</td>
<td>4</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.0</td>
<td>ie/10.0</td>
<td>trident/6.0</td>
<td>4</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>360/3.2.0.6</td>
<td>trident/6.0</td>
<td>4</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>lb/3.1.15.3877</td>
<td>trident/6.0</td>
<td>4</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/3.5.2.1000</td>
<td>trident/6.0</td>
<td>4</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/4.0.5.4000</td>
<td>trident/6.0</td>
<td>4</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.2</td>
<td>tao/3.1</td>
<td>trident/6.0</td>
<td>4</td>
</tr>
<tr>
<td>at function setCaretToInput(input)<CR>at function(event)<CR>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>sg/2.x</td>
<td>trident/6.0</td>
<td>3</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.2</td>
<td>tao/3.0</td>
<td>trident/6.0</td>
<td>3</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>qq/7.3.8581.400</td>
<td>trident/6.0</td>
<td>2</td>
</tr>
<tr>
<td>at function setCaretToInput(input)<CR>at function (event)<CR>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.2</td>
<td>ie/10.0</td>
<td>trident/6.0</td>
<td>2</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>qq/6.14.14517.201</td>
<td>trident/6.0</td>
<td>1</td>
</tr>
<tr>
<td>at function setCaretToInput(input)<CR>at function (event)<CR>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>sg/2.x</td>
<td>trident/6.0</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>4744</td>
</tr>
</tbody>
</table>
<h2 id="top2">TOP2</h2><table>
<thead>
<tr>
<th>KEY</th>
<th>VALUE</th>
</tr>
</thead>
<tbody>
<tr>
<td>URL</td>
<td><a href="https://www.example.com/index.htm">https://www.example.com/index.htm</a></td>
</tr>
<tr>
<td>File</td>
<td><a href="https://a.example.com/??seajs/1.3.1/sea.js,seajs/1.3.1/plugin-combo.js,jquery/jquery/1.7.2/jquery.js">https://a.example.com/??seajs/1.3.1/sea.js,seajs/1.3.1/plugin-combo.js,jquery/jquery/1.7.2/jquery.js</a></td>
</tr>
<tr>
<td>Line</td>
<td>35</td>
</tr>
<tr>
<td>Message</td>
<td>无法获取未定义或 null 引用的属性“length”</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>stack trace</th>
<th>device</th>
<th>os</th>
<th>browser</th>
<th>engine</th>
<th>count</th>
</tr>
</thead>
<tbody>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>ie/10.0</td>
<td>trident/6.0</td>
<td>2192</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>sg/2.x</td>
<td>trident/6.0</td>
<td>1255</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.2</td>
<td>ie/10.0</td>
<td>trident/6.0</td>
<td>352</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>baidu/2.x</td>
<td>trident/6.0</td>
<td>143</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>tw/3.6.1.1</td>
<td>trident/6.0</td>
<td>42</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/4.0.6.2000</td>
<td>trident/6.0</td>
<td>33</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>tw/3.6.1.0</td>
<td>trident/6.0</td>
<td>32</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>tao/3.0</td>
<td>trident/6.0</td>
<td>13</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.2</td>
<td>tw/3.6.1.1</td>
<td>trident/6.0</td>
<td>13</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/3.4.5.2000</td>
<td>trident/6.0</td>
<td>11</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>qq/7.3.8126.400</td>
<td>trident/6.0</td>
<td>9</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.2</td>
<td>tao/3.0</td>
<td>trident/6.0</td>
<td>9</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>360/3.9.1.5</td>
<td>trident/6.0</td>
<td>6</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/3.4.1.1000</td>
<td>trident/6.0</td>
<td>6</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/4.0.3.3000</td>
<td>trident/6.0</td>
<td>6</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>qq/6.14.14517.201</td>
<td>trident/6.0</td>
<td>6</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>qq/6.14.15493.201</td>
<td>trident/6.0</td>
<td>5</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>360/3.2.0.2</td>
<td>trident/6.0</td>
<td>4</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>qq/7.3.11251.400</td>
<td>trident/6.0</td>
<td>4</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>360/3.1.6.7</td>
<td>trident/6.0</td>
<td>3</td>
</tr>
<tr>
<td>at function(a,c,d)</td>
<td>pc/-1</td>
<td>windows/6.2</td>
<td>sy/-1</td>
<td>trident/6.0</td>
<td>3</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>4147</td>
</tr>
</tbody>
</table>
<hr>
<p>TOP1 和 TOP2 两个异常都是中 memberprod 系统的注册页面上（重要程度不想而知），
一个页面是注册的起始页，一个是注册的完成页。我们先分析起始页。</p>
<p>打开异常所在文件第 35行，搜索异常栈信息中的 <code>function(a,c,d)</code>，我们发现有 3 个如下：</p>
<div class="highlight"><pre><code class="javascript">each:<span class="function"><span class="keyword">function</span><span class="params">(a,c,d)</span>{</span><span class="keyword">var</span> f,g=<span class="number">0</span>,h=a.length,i=h===b||e.isFunction(a);<span class="keyword">if</span>(d){<span class="keyword">if</span>(i){<span class="keyword">for</span>(f <span class="keyword">in</span> a)<span class="keyword">if</span>(c.apply(a[f],d)===!<span class="number">1</span>)<span class="keyword">break</span>}<span class="keyword">else</span> <span class="keyword">for</span>(;g&lt;h;)<span class="keyword">if</span>(c.apply(a[g++],d)===!<span class="number">1</span>)<span class="keyword">break</span>}<span class="keyword">else</span> <span class="keyword">if</span>(i){<span class="keyword">for</span>(f <span class="keyword">in</span> a)<span class="keyword">if</span>(c.call(a[f],f,a[f])===!<span class="number">1</span>)<span class="keyword">break</span>}<span class="keyword">else</span> <span class="keyword">for</span>(;g&lt;h;)<span class="keyword">if</span>(c.call(a[g],g,a[g++])===!<span class="number">1</span>)<span class="keyword">break</span>;<span class="keyword">return</span> a}
map:<span class="function"><span class="keyword">function</span><span class="params">(a,c,d)</span>{</span><span class="keyword">var</span> f,g,h=[],i=<span class="number">0</span>,j=a.length,k=a <span class="keyword">instanceof</span> e||j!==b&amp;&amp;<span class="keyword">typeof</span> j==<span class="string">"number"</span>&amp;&amp;(j&gt;<span class="number">0</span>&amp;&amp;a[<span class="number">0</span>]&amp;&amp;a[j-<span class="number">1</span>]||j===<span class="number">0</span>||e.isArray(a));<span class="keyword">if</span>(k)<span class="keyword">for</span>(;i&lt;j;i++)f=c(a[i],i,d),f!=<span class="literal">null</span>&amp;&amp;(h[h.length]=f);<span class="keyword">else</span> <span class="keyword">for</span>(g <span class="keyword">in</span> a)f=c(a[g],g,d),f!=<span class="literal">null</span>&amp;&amp;(h[h.length]=f);<span class="keyword">return</span> h.concat.apply([],h)}
prop:<span class="function"><span class="keyword">function</span><span class="params">(a,c,d)</span>{</span><span class="keyword">var</span> e,g,h,i=a.nodeType;<span class="keyword">if</span>(!!a&amp;&amp;i!==<span class="number">3</span>&amp;&amp;i!==<span class="number">8</span>&amp;&amp;i!==<span class="number">2</span>){h=i!==<span class="number">1</span>||!f.isXMLDoc(a),h&amp;&amp;(c=f.propFix[c]||c,g=f.propHooks[c]);<span class="keyword">return</span> d!==b?g&amp;&amp;<span class="string">"set"</span><span class="keyword">in</span> g&amp;&amp;(e=g.set(a,d,c))!==b?e:a[c]=d:g&amp;&amp;<span class="string">"get"</span><span class="keyword">in</span> g&amp;&amp;(e=g.get(a,c))!==<span class="literal">null</span>?e:a[c]}}</code></pre></div><p>再找异常信息中的关键字 <code>length</code>，发现上面的 prop 方法中并没有这个关键字，
所以可以排除。剩下的两个函数对应的原始码如下：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// args is for internal usage only</span>
each: <span class="function"><span class="keyword">function</span><span class="params">( object, callback, args )</span> {</span>
  <span class="keyword">var</span> name, i = <span class="number">0</span>,
      length = object.length,
      isObj = length === <span class="literal">undefined</span> || jQuery.isFunction( object );

  <span class="keyword">if</span> ( args ) {
    <span class="keyword">if</span> ( isObj ) {
      <span class="keyword">for</span> ( name <span class="keyword">in</span> object ) {
        <span class="keyword">if</span> ( callback.apply( object[ name ], args ) === <span class="literal">false</span> ) {
          <span class="keyword">break</span>;
        }
      }
    } <span class="keyword">else</span> {
      <span class="keyword">for</span> ( ; i &lt; length; ) {
        <span class="keyword">if</span> ( callback.apply( object[ i++ ], args ) === <span class="literal">false</span> ) {
          <span class="keyword">break</span>;
        }
      }
    }

    <span class="comment">// A special, fast, case for the most common use of each</span>
  } <span class="keyword">else</span> {
    <span class="keyword">if</span> ( isObj ) {
      <span class="keyword">for</span> ( name <span class="keyword">in</span> object ) {
        <span class="keyword">if</span> ( callback.call( object[ name ], name, object[ name ] ) === <span class="literal">false</span> ) {
          <span class="keyword">break</span>;
        }
      }
    } <span class="keyword">else</span> {
      <span class="keyword">for</span> ( ; i &lt; length; ) {
        <span class="keyword">if</span> ( callback.call( object[ i ], i, object[ i++ ] ) === <span class="literal">false</span> ) {
          <span class="keyword">break</span>;
        }
      }
    }
  }

  <span class="keyword">return</span> object;
},

<span class="comment">// arg is for internal usage only</span>
map: <span class="function"><span class="keyword">function</span><span class="params">( elems, callback, arg )</span> {</span>
  <span class="keyword">var</span> value, key, ret = [],
    i = <span class="number">0</span>,
    length = elems.length,
    <span class="comment">// jquery objects are treated as arrays</span>
    isArray = elems <span class="keyword">instanceof</span> jQuery || length !== <span class="literal">undefined</span> &amp;&amp; <span class="keyword">typeof</span> length === <span class="string">"number"</span> &amp;&amp; ( ( length &gt; <span class="number">0</span> &amp;&amp; elems[ <span class="number">0</span> ] &amp;&amp; elems[ length -<span class="number">1</span> ] ) || length === <span class="number">0</span> || jQuery.isArray( elems ) ) ;

  <span class="comment">// Go through the array, translating each of the items to their</span>
  <span class="keyword">if</span> ( isArray ) {
    <span class="keyword">for</span> ( ; i &lt; length; i++ ) {
      value = callback( elems[ i ], i, arg );

      <span class="keyword">if</span> ( value != <span class="literal">null</span> ) {
        ret[ ret.length ] = value;
      }
    }

  <span class="comment">// Go through every key on the object,</span>
  } <span class="keyword">else</span> {
    <span class="keyword">for</span> ( key <span class="keyword">in</span> elems ) {
      value = callback( elems[ key ], key, arg );

      <span class="keyword">if</span> ( value != <span class="literal">null</span> ) {
        ret[ ret.length ] = value;
      }
    }
  }

  <span class="comment">// Flatten any nested arrays</span>
  <span class="keyword">return</span> ret.concat.apply( [], ret );
},</code></pre></div><p>这两个函数都有可能性，但是从经验上 each 方法用的更多，我猜这个命中率更高。
但是单纯的从这些异常信息字面量来看，已经没有了更多信息。我们当时还没有注意到
异常都是 Trident 6.0 抛出的。</p>
<hr>
<p>打开页面标准模式或兼容模式下都没有抛出这个异常，只是兼容模式下有个
『找不到成员。』的异常。</p>
<p>手贱点了表单第一个输入框，终于重现了梦寐以求的异常。它就是 each 方法中抛出的。
从调用堆栈信息中可以看到 <code>this.items</code> 是 undefined，导致 each 失败。</p>
<p><img src="https://f.cloud.github.com/assets/143572/860087/e82abdc4-f595-11e2-9f61-abdee317416e.png" alt="2013-07-23 9 12 58"></p>
<p>而 <code>this.items</code> 为 undefined 是由于 validator 的 core 模块中 setup() 函数中
设置 novalidator 属性异常导致后续代码没有执行造成。</p>
<div class="highlight"><pre><code class="javascript">setup: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>

  <span class="comment">//disable html5 form validation</span>
  <span class="keyword">this</span>.element.attr(<span class="string">'novalidate'</span>, <span class="string">'novalidate'</span>);

  <span class="comment">//Validation will be executed according to configurations stored in items.</span>
  <span class="keyword">this</span>.items = [];

  <span class="comment">//...</span>

}</code></pre></div><p>至此，上周支付宝全站 TOP5 的异常均已告破，他们都是同一个问题造成的。</p>
<h2 id="如何解决这个异常？">如何解决这个异常？</h2><p>Validator 组件已于 3个月前的 v0.9.3 版本得到修复，请升级到 Validator 最新版。</p>
<h2 id="一个问题？">一个问题？</h2><p>基础组件中小版本升级修复各种 BUG 的过程中，如何同步推动业务代码的对应升级？</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[每周异常：第 2 期]]></title>
        <link href="http://blog.hotoo.me/post/weekly-topic-about-exceptions-2"/>
        <published>2013-07-22T00:00:00.000Z</published>
        <updated>2013-07-22T00:00:00.000Z</updated>
        <id>http://blog.hotoo.me/post/weekly-topic-about-exceptions-2</id>
        <content type="html" xml:base="http://blog.hotoo.me" xml:lang="en">
            <![CDATA[ <p>这是全站排名第 4 的一个异常，详情如下：</p>
<table>
<thead>
<tr>
<th>KEY</th>
<th>VALUE</th>
</tr>
</thead>
<tbody>
<tr>
<td>URL</td>
<td><a href="https://www.example.com/console/selectStrategy.htm">https://www.example.com/console/selectStrategy.htm</a></td>
</tr>
<tr>
<td>File</td>
<td><a href="https://a.example.com/??seajs/1.3.1/sea.js,seajs/1.3.1/plugin-combo.js,jquery/jquery/1.7.2/jquery.js">https://a.example.com/??seajs/1.3.1/sea.js,seajs/1.3.1/plugin-combo.js,jquery/jquery/1.7.2/jquery.js</a></td>
</tr>
<tr>
<td>Line</td>
<td>35</td>
</tr>
<tr>
<td>Message</td>
<td>找不到成员。<CR><CR></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Stack Trace</th>
<th>Device</th>
<th>OS</th>
<th>Browser</th>
<th>Engine</th>
<th>Count</th>
</tr>
</thead>
<tbody>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>ie/10.0</td>
<td>trident/6.0</td>
<td>826</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>sg/2.x</td>
<td>trident/6.0</td>
<td>423</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.2</td>
<td>ie/10.0</td>
<td>trident/6.0</td>
<td>151</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>baidu/2.x</td>
<td>trident/6.0</td>
<td>27</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/3.4.5.2000</td>
<td>trident/6.0</td>
<td>10</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>tw/3.6.1.1</td>
<td>trident/6.0</td>
<td>10</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.2</td>
<td>mx/4.0.6.2000</td>
<td>trident/6.0</td>
<td>3</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>lb/undefined</td>
<td>trident/6.0</td>
<td>2</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/3.5.2.1000</td>
<td>trident/6.0</td>
<td>2</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/4.0.5.3000</td>
<td>trident/6.0</td>
<td>2</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/4.0.5.4000</td>
<td>trident/6.0</td>
<td>2</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/4.0.6.2000</td>
<td>trident/6.0</td>
<td>2</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>qq/7.3.11251.400</td>
<td>trident/6.0</td>
<td>2</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.2</td>
<td>tw/-1</td>
<td>trident/6.0</td>
<td>2</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>360/3.7.1.6</td>
<td>trident/6.0</td>
<td>1</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>360/4.0.3.6</td>
<td>trident/6.0</td>
<td>1</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>360/4.0.5.2</td>
<td>trident/6.0</td>
<td>1</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/2.5.15.1000</td>
<td>trident/6.0</td>
<td>1</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/2.5.16.100</td>
<td>trident/6.0</td>
<td>1</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/4.0.3.6000</td>
<td>trident/6.0</td>
<td>1</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/4.0.5.2000</td>
<td>trident/6.0</td>
<td>1</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>mx/4.1.0.2000</td>
<td>trident/6.0</td>
<td>1</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>qq/6.13.13719.201</td>
<td>trident/6.0</td>
<td>1</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>qq/6.14.15493.201</td>
<td>trident/6.0</td>
<td>1</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>tw/3.4.0.5</td>
<td>trident/6.0</td>
<td>1</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.1</td>
<td>tw/3.6.1.0</td>
<td>trident/6.0</td>
<td>1</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.2</td>
<td>mx/3.5.2.1000</td>
<td>trident/6.0</td>
<td>1</td>
</tr>
<tr>
<td>at function(a,b,d)</td>
<td>pc/-1</td>
<td>windows/6.2</td>
<td>mx/4.0.5.3000</td>
<td>trident/6.0</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1478</td>
</tr>
</tbody>
</table>
<hr>
<p>首先我们找到异常所在文件的第 35行，在上面的异常栈信息中我们可以知道异常从
压缩后的匿名函数 <code>function(a,b,d)</code> 中抛出，这个函数是：</p>
<div class="highlight"><pre><code class="javascript">set:<span class="function"><span class="keyword">function</span><span class="params">(a,b,d)</span>{</span><span class="keyword">var</span> e=a.getAttributeNode(d);e||(e=c.createAttribute(d),a.setAttributeNode(e));<span class="keyword">return</span> e.nodeValue=b+<span class="string">""</span>}</code></pre></div><p>对应压缩前的源码是：</p>
<div class="highlight"><pre><code class="javascript">    <span class="comment">// Use this for any attribute in IE6/7</span>
    <span class="comment">// This fixes almost every IE6/7 issue</span>
    nodeHook = jQuery.valHooks.button = {
        get: <span class="function"><span class="keyword">function</span><span class="params">( elem, name )</span> {</span>
            <span class="keyword">var</span> ret;
            ret = elem.getAttributeNode( name );
            <span class="keyword">return</span> ret &amp;&amp; ( fixSpecified[ name ] ? ret.nodeValue !== <span class="string">""</span> : ret.specified ) ?
                ret.nodeValue :
                <span class="literal">undefined</span>;
        },
        set: <span class="function"><span class="keyword">function</span><span class="params">( elem, value, name )</span> {</span>
            <span class="comment">// Set the existing or create a new attribute node</span>
            <span class="keyword">var</span> ret = elem.getAttributeNode( name );
            <span class="keyword">if</span> ( !ret ) {
                ret = document.createAttribute( name );
                elem.setAttributeNode( ret );
            }
            <span class="keyword">return</span> ( ret.nodeValue = value + <span class="string">""</span> );
        }
    };</code></pre></div><p>这个代码是用来兼容 IE6/7 的属性操作（代码注释中号称几乎修复了 IE6/7 所有的问题），
页面中的业务源码中我们找到不少 DOM 属性的操作，其中有一些看起来几乎不会有问题，
另外一些则出现问题的可能性更高。</p>
<p>我们从这些可能性更高的部分着手，最终发现 IE10 兼容模式下会抛出『<a href="https://github.com/totorojs/javascript-exception-archives/blob/master/content/wiki/member-not-found">找不到成员。</a>』
的异常，这时我们注意到，异常详情中全部都是 Trident 6.0 内核的浏览器抛出的异常。
看来我们这个增加兼容模式信息的 <a href="https://github.com/totorojs/monitor.js/issues/13">Issues#13</a>
是正确的。</p>
<p>我们看到兼容模式下表单中的 Select 模拟组件显示不正常，最初以为是 Select 组件设置属性造成的异常。</p>
<p><img src="https://f.cloud.github.com/assets/143572/834321/3db467be-f2bb-11e2-93c0-007ec07ba729.png" alt="1c00b54eaad3a6f45ffec0d7526abc6e"></p>
<p>（正常情况下的 Select 模拟组件）</p>
<p><img src="https://f.cloud.github.com/assets/143572/834325/57343714-f2bb-11e2-84aa-fb8834763fce.png" alt="0aafc43da07d07423e1f67199cf5c5b9"></p>
<p>（兼容模式下的 Select 模拟组件）</p>
<p>IE10 的调试工具还是不错的，最终我们发现在设置 &quot;novalidate&quot; 属性时抛出这个异常，
想到 Validator 的相关 <a href="https://github.com/aralejs/validator/issues/30">Issues#30</a></p>
<p><img src="https://f.cloud.github.com/assets/143572/834340/6db729a6-f2bb-11e2-8558-a8f9681f99bf.png" alt="edde87186b5919bd49a4d74874c7ce36"></p>
<p>于是这个异常就破解完成。</p>
<h2 id="如何修复这个异常？">如何修复这个异常？</h2><p>找回密码的这个页面使用的 Validator@0.8.9，而 novalidate 属性造成的异常在
Validator@0.9.3 及其后续版本中得到修复。建议升级到最新版本。</p>
]]>
        </content>
    </entry>
</feed>